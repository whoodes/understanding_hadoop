<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="5217px" height="3721px" viewBox="-0.5 -0.5 5217 3721" content="&lt;mxfile modified=&quot;2019-06-28T02:28:26.805Z&quot; host=&quot;www.draw.io&quot; agent=&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36&quot; version=&quot;10.8.2&quot; etag=&quot;aZllFA73GcAprEIJ9zo9&quot; type=&quot;device&quot;&gt;&lt;diagram id=&quot;M0jy9vFzieRspigNudMO&quot;&gt;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&lt;/diagram&gt;&lt;/mxfile&gt;"><defs/><g><rect x="0" y="9" width="730" height="1230" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(4.5,-1.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="713" height="1235" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 1235px; max-width: 715px; width: 714px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>ReduceTask.java</h1><pre>@Override<br />@SuppressWarnings(<span>"unchecked"</span>)<br /><span>public void </span>run(JobConf job<span>, final </span>TaskUmbilicalProtocol umbilical)<br /><span>throws </span>IOException<span>, </span>InterruptedException<span>, </span>ClassNotFoundException {<br />  job.setBoolean(JobContext.SKIP_RECORDS<span>, </span>isSkipping())<span>;<br /></span><span><br /></span><span>  if </span>(isMapOrReduce()) {<br />    copyPhase = getProgress().addPhase(<span>"copy"</span>)<span>;<br /></span>    sortPhase  = getProgress().addPhase(<span>"sort"</span>)<span>;<br /></span>    reducePhase = getProgress().addPhase(<span>"reduce"</span>)<span>;<br /></span>  }</pre><pre><br /><span>  // start thread that will handle communication with parent<br /></span>  TaskReporter reporter = startReporter(umbilical)<span>;<br /></span><span><br /></span><span>  boolean </span>useNewApi = job.getUseNewReducer()<span>;<br /></span>  initialize(job<span>, </span>getJobID()<span>, </span>reporter<span>, </span>useNewApi)<span>;<br /></span><span><br /></span><span>  // check if it is a cleanupJobTask<br /></span><span>  if </span>(jobCleanup) {<br />    runJobCleanupTask(umbilical<span>, </span>reporter)<span>;<br /></span><span>    return;<br /></span>  }<br /><span>  if </span>(jobSetup) {<br />    runJobSetupTask(umbilical<span>, </span>reporter)<span>;<br /></span><span>    return;<br /></span>  }<br /><span>  if </span>(taskCleanup) {<br />    runTaskCleanupTask(umbilical<span>, </span>reporter)<span>;<br /></span><span>    return;<br /></span>  }<br /><br /><span>  // Initialize the codec<br /></span>  codec = initCodec()<span>;<br /></span>  RawKeyValueIterator rIter = <span>null;<br /></span>  ShuffleConsumerPlugin shuffleConsumerPlugin = <span>null;<br /></span><span><br /></span>  Class combinerClass = conf.getCombinerClass()<span>;<br /></span>  CombineOutputCollector combineCollector = <br />    (<span>null </span>!= combinerClass) ? <br /><span>    new </span>CombineOutputCollector(reduceCombineOutputCounter<span>, </span>reporter<span>, </span>conf) : <span>null;<br /></span><span><br /></span>  Class&lt;? <span>extends </span>ShuffleConsumerPlugin&gt; clazz =<br />        job.getClass(MRConfig.SHUFFLE_CONSUMER_PLUGIN<span>, </span>Shuffle.<span>class, </span>ShuffleConsumerPlugin.<span>class</span>)<span>;<br /></span><span><br /></span>  shuffleConsumerPlugin = ReflectionUtils.newInstance(clazz<span>, </span>job)<span>;<br /></span>  LOG.info(<span>"Using ShuffleConsumerPlugin: " </span>+ shuffleConsumerPlugin)<span>;<br /></span><span><br /></span>  ShuffleConsumerPlugin.Context shuffleContext = <br /><span>  new </span>ShuffleConsumerPlugin.Context(getTaskID()<span>, </span>job<span>, </span>FileSystem.getLocal(job)<span>, </span>umbilical<span>, <br /></span><span>                super</span>.lDirAlloc<span>, </span>reporter<span>, </span>codec<span>, <br /></span>                combinerClass<span>, </span>combineCollector<span>, <br /></span>                spilledRecordsCounter<span>, </span>reduceCombineInputCounter<span>,<br /></span>                shuffledMapsCounter<span>,<br /></span>                reduceShuffleBytes<span>, </span>failedShuffleCounter<span>,<br /></span>                mergedMapOutputsCounter<span>,<br /></span>                taskStatus<span>, </span>copyPhase<span>, </span>sortPhase<span>, this,<br /></span>                mapOutputFile<span>, </span>localMapFiles)<span>;<br /></span><b><font color="#000000">  shuffleConsumerPlugin.init(shuffleContext);<br /></font></b><span><br /></span><b>  rIter = shuffleConsumerPlugin.run()<span>;<br /></span></b><span><br /></span><span>  // free up the data structures<br /></span>  mapOutputFilesOnDisk.clear()<span>;<br /></span><span><br /></span>  sortPhase.complete()<span>;                         </span><span>// sort is complete<br /></span>  setPhase(TaskStatus.Phase.REDUCE)<span>; <br /></span>  statusUpdate(umbilical)<span>;<br /></span>  Class keyClass = job.getMapOutputKeyClass()<span>;<br /></span>  Class valueClass = job.getMapOutputValueClass()<span>;<br /></span>  RawComparator comparator = job.getOutputValueGroupingComparator()<span>;<br /></span><span><br /></span><span>  if </span>(useNewApi) {<br />    runNewReducer(job<span>, </span>umbilical<span>, </span>reporter<span>, </span>rIter<span>, </span>comparator<span>, <br /></span>    keyClass<span>, </span>valueClass)<span>;<br /></span>  } <span>else </span>{<br />    runOldReducer(job<span>, </span>umbilical<span>, </span>reporter<span>, </span>rIter<span>, </span>comparator<span>,  <br /></span>  keyClass<span>, </span>valueClass)<span>;<br /></span>  }<br /><br />  shuffleConsumerPlugin.close()<span>;<br /></span>  done(umbilical<span>, </span>reporter)<span>;</span><span><br /></span>}</pre></div></div></foreignObject><text x="357" y="624" fill="#333333" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><rect x="790" y="69" width="560" height="370" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(794.5,58.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="540" height="350" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 375px; max-width: 545px; width: 541px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>Shuffle.java</h1><pre>@Override<br /><span>public void </span>init(ShuffleConsumerPlugin.Context context) {<br /><span>  this</span>.context = context<span>;<br /></span><span><br /></span><span>  this</span>.reduceId = context.getReduceId()<span>;<br /></span><span>  this</span>.jobConf = context.getJobConf()<span>;<br /></span><span>  this</span>.umbilical = context.getUmbilical()<span>;<br /></span><span>  this</span>.reporter = context.getReporter()<span>;<br /></span><span>  this</span>.metrics = ShuffleClientMetrics.create(context.getReduceId()<span>,<br /></span><span>      this</span>.jobConf)<span>;<br /></span><span>  this</span>.copyPhase = context.getCopyPhase()<span>;<br /></span><span>  this</span>.taskStatus = context.getStatus()<span>;<br /></span><span>  this</span>.reduceTask = context.getReduceTask()<span>;<br /></span><span>  this</span>.localMapFiles = context.getLocalMapFiles()<span>;<br /></span><span><br /></span>  scheduler = <span>new </span>ShuffleSchedulerImpl&lt;K<span>, </span>V&gt;(jobConf<span>, </span>taskStatus<span>, </span>reduceId<span>,<br /></span><span>      this, </span>copyPhase<span>, </span>context.getShuffledMapsCounter()<span>,<br /></span>      context.getReduceShuffleBytes()<span>, </span>context.getFailedShuffleCounter())<span>;<br /></span><b>  merger = createMergeManager(context)<span>;<br /></span></b>}</pre></div></div></foreignObject><text x="270" y="181" fill="#333333" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><path d="M 330 888 L 781.78 147.1" fill="none" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 784.52 142.62 L 783.86 150.42 L 781.78 147.1 L 777.88 146.78 Z" fill="#82b366" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 789.86 398.85 L 334.36 884.36" fill="none" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 330.76 888.18 L 333 880.68 L 334.36 884.36 L 338.11 885.47 Z" fill="#6c8ebf" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><rect x="1450" y="144" width="560" height="220" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(1454.5,133.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="545" height="210" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 225px; max-width: 545px; width: 545.237px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>Shuffle.java</h1><pre><pre>protected MergeManager&lt;K, V&gt; createMergeManager(<br />    ShuffleConsumerPlugin.Context context) {<br />  return <b>new </b><b>MergeManagerImpl&lt;K<span>, </span>V&gt;(reduceId<span>, </span>jobConf<span>, </span>context.getLocalFS()<span>,<br /></span>    context.getLocalDirAllocator()<span>, </span>reporter<span>, </span>context.getCodec()<span>,<br /></span>    context.getCombinerClass()<span>, </span>context.getCombineCollector()<span>, <br /></span>    context.getSpilledRecordsCounter()<span>,<br /></span>    context.getReduceCombineInputCounter()<span>,<br /></span>    context.getMergedMapOutputsCounter()<span>, this, </span>context.getMergePhase()<span>,<br /></span>    context.getMapOutputFile())</b><b>;</b><br />}</pre></pre></div></div></foreignObject><text x="273" y="111" fill="#333333" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><path d="M 1080.39 379.8 L 1446.15 201.61" fill="none" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 1450.87 199.31 L 1446.11 205.52 L 1446.15 201.61 L 1443.05 199.23 Z" fill="#82b366" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 1447.11 336.94 L 1086.3 388.11" fill="none" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 1081.11 388.84 L 1087.55 384.39 L 1086.3 388.11 L 1088.53 391.33 Z" fill="#6c8ebf" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><rect x="2110" y="9" width="620" height="1560" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(2114.5,-1.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="562" height="1552" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 1565px; max-width: 605px; width: 563px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>MergeManagerImpl.java</h1><pre><pre><pre><span>public </span>MergeManagerImpl(TaskAttemptID reduceId<span>, </span>JobConf jobConf<span>, <br /></span>            FileSystem localFS<span>,<br /></span>            LocalDirAllocator localDirAllocator<span>,  <br /></span>            Reporter reporter<span>,<br /></span>            CompressionCodec codec<span>,<br /></span>            Class&lt;? <span>extends </span>Reducer&gt; combinerClass<span>,<br /></span>            CombineOutputCollector&lt;K<span>,</span>V&gt; combineCollector<span>,<br /></span>            Counters.Counter spilledRecordsCounter<span>,<br /></span>            Counters.Counter reduceCombineInputCounter<span>,<br /></span>            Counters.Counter mergedMapOutputsCounter<span>,<br /></span>            ExceptionReporter exceptionReporter<span>,<br /></span>            Progress mergePhase<span>, </span>MapOutputFile mapOutputFile) {<br /><span>  this</span>.reduceId = reduceId<span>;<br /></span><span>  this</span>.jobConf = jobConf<span>;<br /></span><span>  this</span>.localDirAllocator = localDirAllocator<span>;<br /></span><span>  this</span>.exceptionReporter = exceptionReporter<span>;<br /></span><span><br /></span><span>  this</span>.reporter = reporter<span>;<br /></span><span>  this</span>.codec = codec<span>;<br /></span><span>  this</span>.combinerClass = combinerClass<span>;<br /></span><span>  this</span>.combineCollector = combineCollector<span>;<br /></span><span>  this</span>.reduceCombineInputCounter = reduceCombineInputCounter<span>;<br /></span><span>  this</span>.spilledRecordsCounter = spilledRecordsCounter<span>;<br /></span><span>  this</span>.mergedMapOutputsCounter = mergedMapOutputsCounter<span>;<br /></span><span>  this</span>.mapOutputFile = mapOutputFile<span>;<br /></span><span>  this</span>.mapOutputFile.setConf(jobConf)<span>;<br /></span><span><br /></span><span>  this</span>.localFS = localFS<span>;<br /></span><span>  this</span>.rfs = ((LocalFileSystem)localFS).getRaw()<span>;<br /></span><span><br /></span><span>  final float </span>maxInMemCopyUse =<br />    jobConf.getFloat(MRJobConfig.SHUFFLE_INPUT_BUFFER_PERCENT<span>,<br /></span>      MRJobConfig.DEFAULT_SHUFFLE_INPUT_BUFFER_PERCENT)<span>;<br /></span><span>  if </span>(maxInMemCopyUse &gt; <span>1.0 </span>|| maxInMemCopyUse &lt; <span>0.0</span>) {<br /><span>    throw new </span>IllegalArgumentException(<span>"Invalid value for " </span>+<br />        MRJobConfig.SHUFFLE_INPUT_BUFFER_PERCENT + <span>": " </span>+<br />        maxInMemCopyUse)<span>;<br /></span>  }<br /><br /><span>  // Allow unit tests to fix Runtime memory<br /></span><span>  this</span>.memoryLimit = (<span>long</span>)(jobConf.getLong(<br />      MRJobConfig.REDUCE_MEMORY_TOTAL_BYTES<span>,<br /></span>      Runtime.getRuntime().maxMemory()) * maxInMemCopyUse)<span>;</span></pre><pre><span><br /></span><span>  this</span>.ioSortFactor = jobConf.getInt(MRJobConfig.IO_SORT_FACTOR<span>,<br /></span>    MRJobConfig.DEFAULT_IO_SORT_FACTOR)<span>;<br /></span><span><br /></span><span>  final float </span>singleShuffleMemoryLimitPercent =<br />      jobConf.getFloat(MRJobConfig.SHUFFLE_MEMORY_LIMIT_PERCENT<span>,<br /></span>      DEFAULT_SHUFFLE_MEMORY_LIMIT_PERCENT)<span>;<br /></span><span>  if </span>(singleShuffleMemoryLimitPercent &lt; <span>0.0f<br /></span>    || singleShuffleMemoryLimitPercent &gt; <span>1.0f</span>) {<br /><span>       throw new </span>IllegalArgumentException(<span>"Invalid value for "<br /></span>         + MRJobConfig.SHUFFLE_MEMORY_LIMIT_PERCENT + <span>": "<br /></span>         + singleShuffleMemoryLimitPercent)<span>;<br /></span>  }<br /><br />  usedMemory = <span>0L</span><span>;<br /></span>  commitMemory = <span>0L</span><span>;<br /></span><span>  long </span>maxSingleShuffleLimitConfiged =<br />      (<span>long</span>)(memoryLimit * singleShuffleMemoryLimitPercent)<span>;<br /></span><span>  if</span>(maxSingleShuffleLimitConfiged &gt; Integer.MAX_VALUE) {<br />    maxSingleShuffleLimitConfiged = Integer.MAX_VALUE<span>;<br /></span>    LOG.info(<span>"The max number of bytes for a single in-memory shuffle cannot" </span>+<br /><span>      " be larger than Integer.MAX_VALUE. Setting it to Integer.MAX_VALUE"</span>)<span>;<br /></span>  }<br /><span>  this</span>.maxSingleShuffleLimit = maxSingleShuffleLimitConfiged<span>;<br /></span><span>  this</span>.memToMemMergeOutputsThreshold =<br />      jobConf.getInt(MRJobConfig.REDUCE_MEMTOMEM_THRESHOLD<span>, </span>ioSortFactor)<span>;<br /></span><span>  this</span>.mergeThreshold = (<span>long</span>)(<span>this</span>.memoryLimit * <br />                        jobConf.getFloat(<br />                          MRJobConfig.SHUFFLE_MERGE_PERCENT<span>,<br /></span>                          MRJobConfig.DEFAULT_SHUFFLE_MERGE_PERCENT))<span>;<br /></span>  LOG.info(<span>"MergerManager: memoryLimit=" </span>+ memoryLimit + <span>", " </span>+<br /><span>           "maxSingleShuffleLimit=" </span>+ maxSingleShuffleLimit + <span>", " </span>+<br /><span>           "mergeThreshold=" </span>+ mergeThreshold + <span>", " </span>+ <br /><span>           "ioSortFactor=" </span>+ ioSortFactor + <span>", " </span>+<br /><span>           "memToMemMergeOutputsThreshold=" </span>+ memToMemMergeOutputsThreshold)<span>;<br /></span><span><br /></span><span>  if </span>(<span>this</span>.maxSingleShuffleLimit &gt;= <span>this</span>.mergeThreshold) {<br /><span>    throw new </span>RuntimeException(<span>"Invalid configuration: "<br /></span>      + <span>"maxSingleShuffleLimit should be less than mergeThreshold "<br /></span>      + <span>"maxSingleShuffleLimit: " </span>+ <span>this</span>.maxSingleShuffleLimit<br />      + <span>"mergeThreshold: " </span>+ <span>this</span>.mergeThreshold)<span>;<br /></span>  }<br /><br /><span>  boolean </span>allowMemToMemMerge = <br />    jobConf.getBoolean(MRJobConfig.REDUCE_MEMTOMEM_ENABLED<span>, false</span>)<span>;<br /></span><span>    if </span>(allowMemToMemMerge) {<br /><span>      this</span>.memToMemMerger = <br /><span>        new </span>IntermediateMemoryToMemoryMerger(<span>this,<br /></span>                                             memToMemMergeOutputsThreshold)<span>;<br /></span><span>      this</span>.memToMemMerger.start()<span>;<br /></span>  } <span>else </span>{<br /><span>    this</span>.memToMemMerger = <span>null;<br /></span>  }<br /><br /><span>  this</span>.inMemoryMerger = createInMemoryMerger()<span>;<br /></span><b><span>  this</span>.inMemoryMerger.start()<span>;<br /></span></b><span><br /></span><span>  this</span>.onDiskMerger = <span>new </span>OnDiskMerger(<span>this</span>)<span>;<br /></span><b><span>  this</span>.onDiskMerger.start()<span>;<br /></span></b><span><br /></span><span>  this</span>.mergePhase = mergePhase<span>;<br /></span>}</pre></pre></pre></div></div></foreignObject><text x="281" y="782" fill="#333333" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><path d="M 2009.11 227.4 L 2105.78 70.88" fill="none" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 2108.54 66.41 L 2107.84 74.21 L 2105.78 70.88 L 2101.89 70.53 Z" fill="#82b366" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 2109.13 1532.37 L 2009.63 314.71" fill="none" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 2009.2 309.48 L 2013.26 316.17 L 2009.63 314.71 L 2006.29 316.74 Z" fill="#6c8ebf" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><rect x="2830" y="9" width="450" height="490" fill="#e1d5e7" stroke="#9673a6" pointer-events="none"/><g transform="translate(2834.5,-1.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="374" height="490" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 495px; max-width: 435px; width: 375px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>MergeThread.java</h1><pre><pre><pre><pre><span>public void </span>run() {<br /><span>  while </span>(<span>true</span>) {<br />    List&lt;T&gt; inputs = <span>null;<br /></span><span>    try </span>{<br /><span>      // Wait for notification to start the merge...<br /></span><span>      synchronized </span>(pendingToBeMerged) {<br /><span>        while</span>(pendingToBeMerged.size() &lt;= <span>0</span>) {<br />          pendingToBeMerged.wait()<span>;<br /></span>        }<br /><span>        // Pickup the inputs to merge.<br /></span>        inputs = pendingToBeMerged.removeFirst()<span>;<br /></span>      }<br /><br /><span>      // Merge<br /></span>      <b>merge(inputs)<span>;<br /></span> </b>   } <span>catch </span>(InterruptedException ie) {<br />      numPending.set(<span>0</span>)<span>;<br /></span><span>      return;<br /></span>    } <span>catch</span>(Throwable t) {<br />      numPending.set(<span>0</span>)<span>;<br /></span>      reporter.reportException(t)<span>;<br /></span><span>      return;<br /></span>    } <span>finally </span>{<br /><span>      synchronized </span>(<span>this</span>) {<br />        numPending.decrementAndGet()<span>;<br /></span>        notifyAll()<span>;<br /></span>      }<br />    }<br />  }<br />}</pre></pre></pre></pre></div></div></foreignObject><text x="187" y="251" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><path d="M 2330 1449 L 2826.14 71.45" fill="none" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 2827.92 66.52 L 2828.84 74.29 L 2826.14 71.45 L 2822.25 71.92 Z" fill="#82b366" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 2320 1489 L 2825.02 647.21" fill="none" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 2827.72 642.71 L 2827.12 650.51 L 2825.02 647.21 L 2821.12 646.91 Z" fill="#82b366" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 2828.3 475.06 L 2332.91 1439.34" fill="none" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 2330.51 1444.01 L 2330.6 1436.18 L 2332.91 1439.34 L 2336.82 1439.38 Z" fill="#6c8ebf" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 2828.3 1046.58 L 2324.8 1484.82" fill="none" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 2320.84 1488.27 L 2323.83 1481.03 L 2324.8 1484.82 L 2328.42 1486.31 Z" fill="#6c8ebf" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><rect x="2830" y="579" width="450" height="490" fill="#e1d5e7" stroke="#9673a6" pointer-events="none"/><g transform="translate(2834.5,568.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="374" height="490" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 495px; max-width: 435px; width: 375px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>MergeThread.java</h1><pre><pre><pre><pre><span>public void </span>run() {<br /><span>  while </span>(<span>true</span>) {<br />    List&lt;T&gt; inputs = <span>null;<br /></span><span>    try </span>{<br /><span>      // Wait for notification to start the merge...<br /></span><span>      synchronized </span>(pendingToBeMerged) {<br /><span>        while</span>(pendingToBeMerged.size() &lt;= <span>0</span>) {<br />          pendingToBeMerged.wait()<span>;<br /></span>        }<br /><span>        // Pickup the inputs to merge.<br /></span>        inputs = pendingToBeMerged.removeFirst()<span>;<br /></span>      }<br /><br /><span>      // Merge<br /></span>      <b>merge(inputs)</b><span><b>;</b><br /></span>    } <span>catch </span>(InterruptedException ie) {<br />      numPending.set(<span>0</span>)<span>;<br /></span><span>      return;<br /></span>    } <span>catch</span>(Throwable t) {<br />      numPending.set(<span>0</span>)<span>;<br /></span>      reporter.reportException(t)<span>;<br /></span><span>      return;<br /></span>    } <span>finally </span>{<br /><span>      synchronized </span>(<span>this</span>) {<br />        numPending.decrementAndGet()<span>;<br /></span>        notifyAll()<span>;<br /></span>      }<br />    }<br />  }<br />}</pre></pre></pre></pre></div></div></foreignObject><text x="187" y="251" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><rect x="3500" y="9" width="660" height="1180" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(3504.5,-1.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="645" height="1185" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 1185px; max-width: 645px; width: 645.237px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>MergeManagerImpl.java</h1><pre><pre><pre><pre><span>private class </span>InMemoryMerger <span>extends </span>MergeThread&lt;InMemoryMapOutput&lt;K<span>,</span>V&gt;<span>, </span>K<span>,</span>V&gt; {<br /><br /><span>  public </span>InMemoryMerger(MergeManagerImpl&lt;K<span>, </span>V&gt; manager) {<br /><span>    super</span>(manager<span>, </span>Integer.MAX_VALUE<span>, </span>exceptionReporter)<span>;<br /></span>    setName<br />    (<span>"InMemoryMerger - Thread to merge in-memory shuffled map-outputs"</span>)<span>;<br /></span>    setDaemon(<span>true</span>)<span>;<br /></span>}<br /><br />  @Override<br /><span>  public void </span>merge(List&lt;InMemoryMapOutput&lt;K<span>,</span>V&gt;&gt; inputs) <span>throws </span>IOException {<br /><span>    if </span>(inputs == <span>null </span>|| inputs.size() == <span>0</span>) {<br /><span>      return;<br /></span>    }<br /><br /><span>    //name this output file same as the name of the first file that is <br /></span><span>    //there in the current list of inmem files (this is guaranteed to<br /></span><span>    //be absent on the disk currently. So we don't overwrite a prev. <br /></span><span>    //created spill). Also we need to create the output file now since<br /></span><span>    //it is not guaranteed that this file will be present after merge<br /></span><span>    //is called (we delete empty files as soon as we see them<br /></span><span>    //in the merge method)<br /></span><span><br /></span><span>    //figure out the mapId <br /></span>    TaskAttemptID mapId = inputs.get(<span>0</span>).getMapId()<span>;<br /></span>    TaskID mapTaskId = mapId.getTaskID()<span>;<br /></span><span><br /></span>    List&lt;Segment&lt;K<span>, </span>V&gt;&gt; inMemorySegments = <span>new </span>ArrayList&lt;Segment&lt;K<span>, </span>V&gt;&gt;()<span>;<br /></span><span>    long </span>mergeOutputSize = createInMemorySegments(inputs<span>, </span>inMemorySegments<span>,</span><span>0</span>)<span>;<br /></span><span>    int </span>noInMemorySegments = inMemorySegments.size()<span>;<br /></span><span><br /></span>    Path outputPath = mapOutputFile.getInputFileForWrite(mapTaskId<span>,<br /></span>                    mergeOutputSize).suffix(<br />                                     Task.MERGED_OUTPUT_PREFIX)<span>;<br /></span><span><br /></span>    FSDataOutputStream out = CryptoUtils.wrapIfNecessary(jobConf<span>, </span>rfs.create(outputPath))<span>;<br /></span>    Writer&lt;K<span>, </span>V&gt; writer = <span>new </span>Writer&lt;K<span>, </span>V&gt;(jobConf<span>, </span>out<span>,<br /></span>      (Class&lt;K&gt;) jobConf.getMapOutputKeyClass()<span>,<br /></span>      (Class&lt;V&gt;) jobConf.getMapOutputValueClass()<span>, </span>codec<span>, null, true</span>)<span>;<br /></span><span><br /></span>    RawKeyValueIterator rIter = <span>null;<br /></span>    CompressAwarePath compressAwarePath<span>;<br /></span><span>    try </span>{<br />      LOG.info(<span>"Initiating in-memory merge with " </span>+ noInMemorySegments + <br /><span>               " segments..."</span>)<span>;<br /></span><span><br /></span>      rIter = <b>Merger.merge(jobConf<span>, </span>rfs<span>,<br /></span>                          (Class&lt;K&gt;)jobConf.getMapOutputKeyClass()<span>,<br /></span>                          (Class&lt;V&gt;)jobConf.getMapOutputValueClass()<span>,<br /></span>                           inMemorySegments<span>, </span>inMemorySegments.size()<span>,<br /></span><span>                           new </span>Path(reduceId.toString())<span>,<br /></span>                          (RawComparator&lt;K&gt;)jobConf.getOutputKeyComparator()<span>,<br /></span>                           reporter<span>, </span>spilledRecordsCounter<span>, null, null</span>)</b><span><b>;</b><br /></span><span><br /></span><span>      if </span>(<span>null </span>== combinerClass) {<br />        Merger.writeFile(rIter<span>, </span>writer<span>, </span>reporter<span>, </span>jobConf)<span>;<br /></span>      } <span>else </span>{<br />        combineCollector.setWriter(writer)<span>;<br /></span>        combineAndSpill(rIter<span>, </span>reduceCombineInputCounter)<span>;<br /></span>      }<br />      writer.close()<span>;<br /></span>      compressAwarePath = <span>new </span>CompressAwarePath(outputPath<span>,<br /></span>      writer.getRawLength()<span>, </span>writer.getCompressedLength())<span>;<br /></span><span><br /></span>      LOG.info(reduceId +  <br /><span>               " Merge of the " </span>+ noInMemorySegments +<br /><span>               " files in-memory complete." </span>+<br /><span>               " Local file is " </span>+ outputPath + <span>" of size " </span>+ <br />               localFS.getFileStatus(outputPath).getLen())<span>;<br /></span>    } <span>catch </span>(IOException e) { <br /><span>      //make sure that we delete the ondisk file that we created <br /></span><span>      //earlier when we invoked cloneFileAttributes<br /></span>      localFS.delete(outputPath<span>, true</span>)<span>;<br /></span><span>      throw </span>e<span>;<br /></span>    }<br /><br /><span>    // Note the output of the merge<br /></span>    closeOnDiskFile(compressAwarePath)<span>;<br /></span>  }<br />}</pre></pre></pre></pre></div></div></foreignObject><text x="323" y="599" fill="#333333" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><path d="M 2980.7 260.73 L 3495.07 208.34" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/><rect x="3500" y="1219" width="660" height="1100" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(3504.5,1208.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="645" height="1105" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 1105px; max-width: 645px; width: 645.237px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>MergeManagerImpl.java</h1><pre><pre><pre><pre><pre><span>private class </span>OnDiskMerger <span>extends </span>MergeThread&lt;CompressAwarePath<span>,</span>K<span>,</span>V&gt; {<br /><br /><span>  public </span>OnDiskMerger(MergeManagerImpl&lt;K<span>, </span>V&gt; manager) {<br /><span>    super</span>(manager<span>, </span>ioSortFactor<span>, </span>exceptionReporter)<span>;<br /></span>    setName(<span>"OnDiskMerger - Thread to merge on-disk map-outputs"</span>)<span>;<br /></span>    setDaemon(<span>true</span>)<span>;<br /></span>  }<br /><br />  @Override<br /><span>  public void </span>merge(List&lt;CompressAwarePath&gt; inputs) <span>throws </span>IOException {<br /><span>    // sanity check<br /></span><span>    if </span>(inputs == <span>null </span>|| inputs.isEmpty()) {<br />      LOG.info(<span>"No ondisk files to merge..."</span>)<span>;<br /></span><span>      return;<br /></span>    }<br /><br /><span>    long </span>approxOutputSize = <span>0</span><span>;<br /></span><span>    int </span>bytesPerSum = <br />      jobConf.getInt(<span>"io.bytes.per.checksum"</span><span>, </span><span>512</span>)<span>;<br /></span><span><br /></span>    LOG.info(<span>"OnDiskMerger: We have  " </span>+ inputs.size() + <br /><span>             " map outputs on disk. Triggering merge..."</span>)<span>;<br /></span><span><br /></span><span>    // 1. Prepare the list of files to be merged. <br /></span><span>    for </span>(CompressAwarePath file : inputs) {<br />      approxOutputSize += localFS.getFileStatus(file).getLen()<span>;<br /></span>    }<br /><br /><span>    // add the checksum length<br /></span>    approxOutputSize += <br />      ChecksumFileSystem.getChecksumLength(approxOutputSize<span>, </span>bytesPerSum)<span>;<br /></span><span><br /></span><span>    // 2. Start the on-disk merge process<br /></span>    Path outputPath = <br />      localDirAllocator.getLocalPathForWrite(inputs.get(<span>0</span>).toString()<span>, <br /></span>        approxOutputSize<span>, </span>jobConf).suffix(Task.MERGED_OUTPUT_PREFIX)<span>;<br /></span><span><br /></span>    FSDataOutputStream out = CryptoUtils.wrapIfNecessary(jobConf<span>, </span>rfs.create(outputPath))<span>;<br /></span>    Writer&lt;K<span>, </span>V&gt; writer = <span>new </span>Writer&lt;K<span>, </span>V&gt;(jobConf<span>, </span>out<span>,<br /></span>                         (Class&lt;K&gt;) jobConf.getMapOutputKeyClass()<span>,<br /></span>                         (Class&lt;V&gt;) jobConf.getMapOutputValueClass()<span>, </span>codec<span>, null, true</span>)<span>;<br /></span><span><br /></span>    RawKeyValueIterator iter  = <span>null;<br /></span>    CompressAwarePath compressAwarePath<span>;<br /></span>    Path tmpDir = <span>new </span>Path(reduceId.toString())<span>;<br /></span><span>    try </span>{<br />      iter = <b>Merger.merge(jobConf<span>, </span>rfs<span>,<br /></span>                         (Class&lt;K&gt;) jobConf.getMapOutputKeyClass()<span>,<br /></span>                         (Class&lt;V&gt;) jobConf.getMapOutputValueClass()<span>,<br /></span>                          codec<span>, </span>inputs.toArray(<span>new </span>Path[inputs.size()])<span>, <br /></span><span>                          true, </span>ioSortFactor<span>, </span>tmpDir<span>, <br /></span>                         (RawComparator&lt;K&gt;) jobConf.getOutputKeyComparator()<span>, <br /></span>                         reporter<span>, </span>spilledRecordsCounter<span>, null, <br /></span>                         mergedMapOutputsCounter<span>, null</span>)</b><span><b>;</b><br /></span><span><br /></span>      Merger.writeFile(iter<span>, </span>writer<span>, </span>reporter<span>, </span>jobConf)<span>;<br /></span>      writer.close()<span>;<br /></span>      compressAwarePath = <span>new </span>CompressAwarePath(outputPath<span>,   <br /></span>      writer.getRawLength()<span>, </span>writer.getCompressedLength())<span>;<br /></span>    } <span>catch </span>(IOException e) {<br />      localFS.delete(outputPath<span>, true</span>)<span>;<br /></span><span>      throw </span>e<span>;<br /></span>    }<br /><br />    closeOnDiskFile(compressAwarePath)<span>;<br /></span><span><br /></span>    LOG.info(reduceId +<br /><span>             " Finished merging " </span>+ inputs.size() + <br /><span>             " map output files on disk of total-size " </span>+ <br />             approxOutputSize + <span>"." </span>+ <br /><span>             " Local output file is " </span>+ outputPath + <span>" of size " </span>+<br />             localFS.getFileStatus(outputPath).getLen())<span>;<br /></span>  }<br />}</pre></pre></pre></pre></pre></div></div></foreignObject><text x="323" y="559" fill="#333333" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><path d="M 2980.7 837.02 L 3495.07 1399.02" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/><rect x="785" y="634" width="620" height="1170" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(789.5,623.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="598" height="1175" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 1175px; max-width: 605px; width: 599px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>Shuffle.java</h1><pre>@Override<br /><span>public </span>RawKeyValueIterator run() <span>throws </span>IOException<span>, </span>InterruptedException {<br /><span>  // Scale the maximum events we fetch per RPC call to mitigate OOM issues<br /></span><span>  // on the ApplicationMaster when a thundering herd of reducers fetch events<br /></span><span>  // TODO: This should not be necessary after HADOOP-8942<br /></span><span>  int </span>eventsPerReducer = Math.max(MIN_EVENTS_TO_FETCH<span>,<br /></span>  MAX_RPC_OUTSTANDING_EVENTS / jobConf.getNumReduceTasks())<span>;<br /></span><span>  int </span>maxEventsToFetch = Math.min(MAX_EVENTS_TO_FETCH<span>, </span>eventsPerReducer)<span>;<br /></span><span><br /></span><span>  // Start the map-completion events fetcher thread<br /></span><span>  final </span>EventFetcher&lt;K<span>, </span>V&gt; eventFetcher =<br /><span>       new </span>EventFetcher&lt;K<span>, </span>V&gt;(reduceId<span>, </span>umbilical<span>, </span>scheduler<span>, this,<br /></span>       maxEventsToFetch)<span>;<br /></span>  eventFetcher.start()<span>;<br /></span><span><br /></span><span>  // Start the map-output fetcher threads<br /></span><span>  boolean </span>isLocal = localMapFiles != <span>null;<br /></span><span>  final int </span>numFetchers = isLocal ? <span>1 </span>:<br />      jobConf.getInt(MRJobConfig.SHUFFLE_PARALLEL_COPIES<span>, </span><span>5</span>)<span>;<br /></span>  Fetcher&lt;K<span>, </span>V&gt;[] fetchers = <span>new </span>Fetcher[numFetchers]<span>;<br /></span><span>  if </span>(isLocal) {<br />    fetchers[<span>0</span>] = <span>new </span>LocalFetcher&lt;K<span>, </span>V&gt;(jobConf<span>, </span>reduceId<span>, </span>scheduler<span>,<br /></span>                    merger<span>, </span>reporter<span>, </span>metrics<span>, this, </span>reduceTask.getShuffleSecret()<span>,<br /></span>                    localMapFiles)<span>;<br /></span><b>    fetchers[<span>0</span>].start()<span>;<br /></span></b>  } <span>else </span>{<br /><span>    for </span>(<span>int </span>i=<span>0</span><span>; </span>i &lt; numFetchers<span>; </span>++i) {<br />      fetchers[i] = <span>new </span>Fetcher&lt;K<span>, </span>V&gt;(jobConf<span>, </span>reduceId<span>, </span>scheduler<span>, </span>merger<span>,<br /></span>                                     reporter<span>, </span>metrics<span>, this, <br /></span>                                     reduceTask.getShuffleSecret())<span>;<br /></span><b>      fetchers[i].start()<span>;<br /></span></b>    }<br />  }<br /><br /><span>  // Wait for shuffle to complete successfully<br /></span><span>  while </span>(!scheduler.waitUntilDone(PROGRESS_FREQUENCY)) {<br />    reporter.progress()<span>;<br /></span><span><br /></span><span>    synchronized </span>(<span>this</span>) {<br /><span>      if </span>(throwable != <span>null</span>) {<br /><span>        throw new </span>ShuffleError(<span>"error in shuffle in " </span>+ throwingThreadName<span>,<br /></span>                               throwable)<span>;<br /></span>      }<br />    }<br />  }<br /><br /><span>  // Stop the event-fetcher thread<br /></span>  eventFetcher.shutDown()<span>;<br /></span><span><br /></span><span>  // Stop the map-output fetcher threads<br /></span><span>  for </span>(Fetcher&lt;K<span>, </span>V&gt; fetcher : fetchers) {<br />    fetcher.shutDown()<span>;<br /></span>  }<br /><br /><span>  // stop the scheduler<br /></span>  scheduler.close()<span>;<br /></span><span><br /></span>  copyPhase.complete()<span>; </span><span>// copy is already complete<br /></span>  taskStatus.setPhase(TaskStatus.Phase.SORT)<span>;<br /></span>  reduceTask.statusUpdate(umbilical)<span>;<br /></span><span><br /></span><span>  // Finish the on-going merges...<br /></span>  RawKeyValueIterator kvIter = <span>null;<br /></span><span>  try </span>{<br />    kvIter = merger.close()<span>;<br /></span>  } <span>catch </span>(Throwable e) {<br /><span>    throw new </span>ShuffleError(<span>"Error while doing final merge "</span><span>, </span>e)<span>;<br /></span>  }<br /><br /><span>  // Sanity check<br /></span><span>  synchronized </span>(<span>this</span>) {<br /><span>    if </span>(throwable != <span>null</span>) {<br /><span>      throw new </span>ShuffleError(<span>"error in shuffle in " </span>+ throwingThreadName<span>,<br /></span>                           throwable)<span>;<br /></span>    }<br />  }<br /><br /><span>  return </span>kvIter<span>;<br /></span>}</pre></div></div></foreignObject><text x="299" y="594" fill="#333333" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><path d="M 785.1 1780.03 L 283.5 932.99" fill="none" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 280.82 928.47 L 287.4 932.71 L 283.5 932.99 L 281.38 936.28 Z" fill="#6c8ebf" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 280 919 L 774.49 706.18" fill="none" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 779.31 704.11 L 774.26 710.09 L 774.49 706.18 L 771.5 703.66 Z" fill="#82b366" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><rect x="1542.5" y="634" width="430" height="370" fill="#e1d5e7" stroke="#9673a6" pointer-events="none"/><g transform="translate(1547.5,623.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="410" height="375" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 375px; max-width: 415px; width: 411px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>LocalFetcher.java</h1><pre><pre><span>public void </span>run() {<br /><span>  // Create a worklist of task attempts to work over.<br /></span>  Set&lt;TaskAttemptID&gt; maps = <span>new </span>HashSet&lt;TaskAttemptID&gt;()<span>;<br /></span><span>  for </span>(TaskAttemptID map : localMapFiles.keySet()) {<br />    maps.add(map)<span>;<br /></span>  }<br /><br /><span>  while </span>(maps.size() &gt; <span>0</span>) {<br /><span>    try </span>{<br /><span>      // If merge is on, block<br /></span><b>      merger.waitForResource()<span>;<br /></span></b>      metrics.threadBusy()<span>;<br /></span><span><br /></span><span>      // Copy as much as is possible.<br /></span>      doCopy(maps)<span>;<br /></span>      metrics.threadFree()<span>;<br /></span>    } <span>catch </span>(InterruptedException ie) {<br />    } <span>catch </span>(Throwable t) {<br />      exceptionReporter.reportException(t)<span>;<br /></span>    }<br />  }<br />}</pre></pre></div></div></foreignObject><text x="205" y="194" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><rect x="1460" y="1109" width="490" height="440" fill="#e1d5e7" stroke="#9673a6" pointer-events="none"/><g transform="translate(1464.5,1098.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="468" height="445" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 445px; max-width: 475px; width: 469px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>Fetcher.java</h1><pre><pre><pre><span>public void </span>run() {<br /><span>  try </span>{<br /><span>    while </span>(!stopped &amp;&amp; !Thread.currentThread().isInterrupted()) {<br />      MapHost host = <span>null;<br /></span><span>      try </span>{<br /><span>        // If merge is on, block<br /></span><b>        merger.waitForResource()<span>;<br /></span></b><span><br /></span><span>        // Get a host to shuffle from<br /></span><b>        host = scheduler.getHost()<span>;<br /></span></b>        metrics.threadBusy()<span>;<br /></span><span><br /></span><span>        // Shuffle<br /></span>        <b>copyFromHost(host)</b><span><b>;</b><br /></span>      } <span>finally </span>{<br /><span>        if </span>(host != <span>null</span>) {<br />          scheduler.freeHost(host)<span>;<br /></span>          metrics.threadFree()<span>;            <br /></span>        }<br />      }<br />    }<br />  } <span>catch </span>(InterruptedException ie) {<br /><span>    return;<br /></span>  } <span>catch </span>(Throwable t) {<br />    exceptionReporter.reportException(t)<span>;<br /></span>  }<br />}<br /></pre></pre></pre></div></div></foreignObject><text x="234" y="229" fill="#000000" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><path d="M 970.84 1018 L 1536.83 697.28" fill="none" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 1541.4 694.69 L 1537.03 701.19 L 1536.83 697.28 L 1533.58 695.1 Z" fill="#82b366" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 985.13 1113.26 L 1450.31 1164.94" fill="none" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 1455.53 1165.52 L 1448.18 1168.23 L 1450.31 1164.94 L 1448.96 1161.27 Z" fill="#82b366" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 1456.64 1532.37 L 985.17 1122.2" fill="none" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 981.21 1118.75 L 988.79 1120.71 L 985.17 1122.2 L 984.2 1125.99 Z" fill="#6c8ebf" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 1537.61 984.66 L 976.35 1028.5" fill="none" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 971.11 1028.91 L 977.82 1024.88 L 976.35 1028.5 L 978.37 1031.86 Z" fill="#6c8ebf" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><rect x="2690" y="1639" width="590" height="1690" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(2694.5,1628.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="569" height="1694" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 1695px; max-width: 575px; width: 570px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>Fetcher.java</h1><pre><pre><pre><pre><span>private </span>TaskAttemptID[] copyMapOutput(MapHost host<span>,<br /></span>                              DataInputStream input<span>,<br /></span>                              Set&lt;TaskAttemptID&gt; remaining<span>,<br /></span><span>                              boolean </span>canRetry) <span>throws </span>IOException {<br />  MapOutput&lt;K<span>,</span>V&gt; mapOutput = <span>null;<br /></span>  TaskAttemptID mapId = <span>null;<br /></span><span>  long </span>decompressedLength = -<span>1</span><span>;<br /></span><span>  long </span>compressedLength = -<span>1</span><span>;<br /></span><span><br /></span><span>  try </span>{<br /><span>    long </span>startTime = Time.monotonicNow()<span>;<br /></span><span>    int </span>forReduce = -<span>1</span><span>;<br /></span><span>    //Read the shuffle header<br /></span><span>    try </span>{<br />      ShuffleHeader header = <span>new </span>ShuffleHeader()<span>;<br /></span>      header.readFields(input)<span>;<br /></span>      mapId = TaskAttemptID.forName(header.mapId)<span>;<br /></span>      compressedLength = header.compressedLength<span>;<br /></span>      decompressedLength = header.uncompressedLength<span>;<br /></span>      forReduce = header.forReduce<span>;<br /></span>    } <span>catch </span>(IllegalArgumentException e) {<br />      badIdErrs.increment(<span>1</span>)<span>;<br /></span>      LOG.warn(<span>"Invalid map id "</span><span>, </span>e)<span>;<br /></span><span>      //Don't know which one was bad, so consider all of them as bad<br /></span><span>      return </span>remaining.toArray(<span>new </span>TaskAttemptID[remaining.size()])<span>;<br /></span>    }<br /><br />    InputStream is = input<span>;<br /></span>    is = CryptoUtils.wrapIfNecessary(jobConf<span>, </span>is<span>, </span>compressedLength)<span>;<br /></span>    compressedLength -= CryptoUtils.cryptoPadding(jobConf)<span>;<br /></span>    decompressedLength -= CryptoUtils.cryptoPadding(jobConf)<span>;<br /></span><span><br /></span><span>    // Do some basic sanity verification<br /></span><span>    if </span>(!verifySanity(compressedLength<span>, </span>decompressedLength<span>, </span>forReduce<span>,<br /></span>      remaining<span>, </span>mapId)) {<br /><span>      return new </span>TaskAttemptID[] {mapId}<span>;<br /></span>    }<br /><br /><span>    if</span>(LOG.isDebugEnabled()) {<br />      LOG.debug(<span>"header: " </span>+ mapId + <span>", len: " </span>+ compressedLength + <br /><span>                ", decomp len: " </span>+ decompressedLength)<span>;<br /></span>    }<br /><br /><span>    // Get the location for the map output - either in-memory or on-disk<br /></span><span>    try </span>{<br /><b>      mapOutput = merger.reserve(mapId<span>, </span>decompressedLength<span>, </span>id)<span>;<br /></span></b>    } <span>catch </span>(IOException ioe) {<br /><span>      // kill this reduce attempt<br /></span>      ioErrs.increment(<span>1</span>)<span>;<br /></span>      scheduler.reportLocalError(ioe)<span>;<br /></span><span>      return </span>EMPTY_ATTEMPT_ID_ARRAY<span>;<br /></span>    }<br /><br /><span>    // Check if we can shuffle *now* ...<br /></span><span>    if </span>(mapOutput == <span>null</span>) {<br />      LOG.info(<span>"fetcher#" </span>+ id + <span>" - MergeManager returned status WAIT ..."</span>)<span>;<br /></span><span>      //Not an error but wait to process data.<br /></span><span>      return </span>EMPTY_ATTEMPT_ID_ARRAY<span>;<br /></span>    } <br /><br /><span>    // The codec for lz0,lz4,snappy,bz2,etc. throw java.lang.InternalError<br /></span><span>    // on decompression failures. Catching and re-throwing as IOException<br /></span><span>    // to allow fetch failure logic to be processed<br /></span><span>    try </span>{<br /><span>      // Go!<br /></span>      LOG.info(<span>"fetcher#" </span>+ id + <span>" about to shuffle output of map "<br /></span>          + mapOutput.getMapId() + <span>" decomp: " </span>+ decompressedLength<br />          + <span>" len: " </span>+ compressedLength + <span>" to " </span>+ mapOutput.getDescription())<span>;<br /></span>      mapOutput.shuffle(host<span>, </span>is<span>, </span>compressedLength<span>, </span>decompressedLength<span>,<br /></span>      metrics<span>, </span>reporter)<span>;<br /></span>    } <span>catch </span>(java.lang.InternalError | Exception e) {<br />      LOG.warn(<span>"Failed to shuffle for fetcher#"</span>+id<span>, </span>e)<span>;<br /></span><span>      throw new </span>IOException(e)<span>;<br /></span>    }<br /><br /><span>    // Inform the shuffle scheduler<br /></span><span>    long </span>endTime = Time.monotonicNow()<span>;<br /></span><span>    // Reset retryStartTime as map task make progress if retried before.<br /></span>    retryStartTime = <span>0</span><span>;<br /></span><span><br /></span><b>    scheduler.copySucceeded(mapId<span>, </span>host<span>, </span>compressedLength<span>, <br /></span></b>    startTime<span>, </span>endTime<span>, </span>mapOutput)<span>;<br /></span><span>    // Note successful shuffle<br /></span>    remaining.remove(mapId)<span>;<br /></span>    metrics.successFetch()<span>;<br /></span><span>    return null;<br /></span>  } <span>catch </span>(IOException ioe) {<br /><span>    if </span>(mapOutput != <span>null</span>) {<br />      mapOutput.abort()<span>;<br /></span>    }<br /><br /><span>    if </span>(canRetry) {<br />      checkTimeoutOrRetry(host<span>, </span>ioe)<span>;<br /></span>    } <br /><br />    ioErrs.increment(<span>1</span>)<span>;<br /></span><span>    if </span>(mapId == <span>null </span>|| mapOutput == <span>null</span>) {<br />      LOG.warn(<span>"fetcher#" </span>+ id + <span>" failed to read map header" </span>+ <br />               mapId + <span>" decomp: " </span>+ <br />               decompressedLength + <span>", " </span>+ compressedLength<span>, </span>ioe)<span>;<br /></span><span>      if</span>(mapId == <span>null</span>) {<br /><span>        return </span>remaining.toArray(<span>new </span>TaskAttemptID[remaining.size()])<span>;<br /></span>      } <span>else </span>{<br /><span>        return new </span>TaskAttemptID[] {mapId}<span>;<br /></span>      }<br />    }<br /><br />    LOG.warn(<span>"Failed to shuffle output of " </span>+ mapId + <br /><span>             " from " </span>+ host.getHostName()<span>, </span>ioe)<span>; <br /></span><span><br /></span><span>    // Inform the shuffle-scheduler<br /></span>    metrics.failedFetch()<span>;<br /></span><span>    return new </span>TaskAttemptID[] {mapId}<span>;<br /></span>  }<br /><br />}</pre></pre></pre></pre></div></div></foreignObject><text x="285" y="853" fill="#333333" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><path d="M 1661.44 1346.63 L 1851.94 1718.12" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/><rect x="3502" y="2389" width="605" height="650" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(3506.5,2378.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="569" height="655" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 655px; max-width: 590px; width: 570px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>MergeManagerImpl.java</h1><pre><pre><pre><pre><pre>@Override<br /><span>public synchronized </span>MapOutput&lt;K<span>,</span>V&gt; reserve(TaskAttemptID mapId<span>, <br /></span><span>                                           long </span>requestedSize<span>,<br /></span><span>                                           int </span>fetcher<br />                                           ) <span>throws </span>IOException {<br /><span>  if </span>(requestedSize &gt; maxSingleShuffleLimit) {<br />    LOG.info(mapId + <span>": Shuffling to disk since " </span>+ requestedSize + <br /><span>            " is greater than maxSingleShuffleLimit (" </span>+ <br />             maxSingleShuffleLimit + <span>")"</span>)<span>;<br /></span><span>    return new </span>OnDiskMapOutput&lt;K<span>,</span>V&gt;(mapId<span>, this, </span>requestedSize<span>, </span>jobConf<span>,<br /></span>      fetcher<span>, true, </span>FileSystem.getLocal(jobConf).getRaw()<span>,<br /></span>        mapOutputFile.getInputFileForWrite(mapId.getTaskID()<span>, </span>requestedSize))<span>;<br /></span>  }<br /><br /><span>  // Stall shuffle if we are above the memory limit<br /></span><span><br /></span><span>  // It is possible that all threads could just be stalling and not make<br /></span><span>  // progress at all. This could happen when:<br /></span><span>  //<br /></span><span>  // requested size is causing the used memory to go above limit &amp;&amp;<br /></span><span>  // requested size &lt; singleShuffleLimit &amp;&amp;<br /></span><span>  // current used size &lt; mergeThreshold (merge will not get triggered)<br /></span><span>  //<br /></span><span>  // To avoid this from happening, we allow exactly one thread to go past<br /></span><span>  // the memory limit. We check (usedMemory &gt; memoryLimit) and not<br /></span><span>  // (usedMemory + requestedSize &gt; memoryLimit). When this thread is done<br /></span><span>  // fetching, this will automatically trigger a merge thereby unlocking<br /></span><span>  // all the stalled threads<br /></span><span><br /></span><span>  if </span>(usedMemory &gt; memoryLimit) {<br />    LOG.debug(mapId + <span>": Stalling shuffle since usedMemory (" </span>+ usedMemory<br />        + <span>") is greater than memoryLimit (" </span>+ memoryLimit + <span>")." </span>+ <br /><span>        " CommitMemory is (" </span>+ commitMemory + <span>")"</span>)<span>; <br /></span><span>    return null;<br /></span>  }<br /><br /><span>  // Allow the in-memory shuffle to progress<br /></span>  LOG.debug(mapId + <span>": Proceeding with shuffle since usedMemory ("<br /></span>           + usedMemory + <span>") is lesser than memoryLimit (" </span>+ memoryLimit + <span>")."<br /></span>           + <span>"CommitMemory is (" </span>+ commitMemory + <span>")"</span>)<span>; <br /></span><span>  return </span>unconditionalReserve(mapId<span>, </span>requestedSize<span>, true</span>)<span>;<br /></span>}</pre></pre></pre></pre></pre></div></div></foreignObject><text x="285" y="334" fill="#333333" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><path d="M 3495.07 2465.86 L 3161.69 2327.74" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/><rect x="4612" y="2974" width="600" height="410" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(4616.5,2963.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="569" height="415" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 415px; max-width: 585px; width: 570px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>MergeManagerImpl.java</h1><pre><pre><span>public synchronized void </span>closeInMemoryFile(InMemoryMapOutput&lt;K<span>,</span>V&gt; mapOutput) { <br />  inMemoryMapOutputs.add(mapOutput)<span>;<br /></span>  LOG.info(<span>"closeInMemoryFile -&gt; map-output of size: " </span>+ mapOutput.getSize()<br />      + <span>", inMemoryMapOutputs.size() -&gt; " </span>+ inMemoryMapOutputs.size()<br />      + <span>", commitMemory -&gt; " </span>+ commitMemory + <span>", usedMemory -&gt;" </span>+ usedMemory)<span>;<br /></span><span><br /></span>  commitMemory+= mapOutput.getSize()<span>;<br /></span><span><br /></span><span>  // Can hang if mergeThreshold is really low.<br /></span><span>  if </span>(commitMemory &gt;= mergeThreshold) {<br />    LOG.info(<span>"Starting inMemoryMerger's merge since commitMemory=" </span>+<br />        commitMemory + <span>" &gt; mergeThreshold=" </span>+ mergeThreshold + <br /><span>        ". Current usedMemory=" </span>+ usedMemory)<span>;<br /></span>    inMemoryMapOutputs.addAll(inMemoryMergedMapOutputs)<span>;<br /></span>    inMemoryMergedMapOutputs.clear()<span>;<br /></span>    inMemoryMerger.startMerge(inMemoryMapOutputs)<span>;<br /></span>    commitMemory = <span>0L</span><span>;  </span><span>// Reset commitMemory.<br /></span>  }<br /> <br /><span>  if </span>(memToMemMerger != <span>null</span>) {<br /><span>    if </span>(inMemoryMapOutputs.size() &gt;= memToMemMergeOutputsThreshold) { <br />      memToMemMerger.startMerge(inMemoryMapOutputs)<span>;<br /></span>    }<br />  }<br />}</pre></pre></div></div></foreignObject><text x="285" y="214" fill="#333333" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><rect x="1850" y="1654" width="600" height="1155" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(1854.5,1643.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="569" height="1160" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 1160px; max-width: 585px; width: 570px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>Fetcher.java</h1><pre><pre><pre>@VisibleForTesting<br /><span>protected void </span>copyFromHost(MapHost host) <span>throws </span>IOException {<br /><span>  // reset retryStartTime for a new host<br /></span>  retryStartTime = <span>0</span><span>;<br /></span><span>  // Get completed maps on 'host'<br /></span>  List&lt;TaskAttemptID&gt; maps = scheduler.getMapsForHost(host)<span>;<br /></span><span><br /></span><span>  // Sanity check to catch hosts with only 'OBSOLETE' maps, <br /></span><span>  // especially at the tail of large jobs<br /></span><span>  if </span>(maps.size() == <span>0</span>) {<br /><span>    return;<br /></span>  }<br /><br /><span>  if</span>(LOG.isDebugEnabled()) {<br />    LOG.debug(<span>"Fetcher " </span>+ id + <span>" going to fetch from " </span>+ host + <span>" for: "<br /></span>             + maps)<span>;<br /></span>  }<br /><br /><span>  // List of maps to be fetched yet<br /></span>  Set&lt;TaskAttemptID&gt; remaining = <span>new </span>HashSet&lt;TaskAttemptID&gt;(maps)<span>;<br /></span><span><br /></span><span>  // Construct the url and connect<br /></span>  URL url = getMapOutputURL(host<span>, </span>maps)<span>;<br /></span>  DataInputStream input = <span>null;<br /></span><span><br /></span><span>  try </span>{<br />    input = openShuffleUrl(host<span>, </span>remaining<span>, </span>url)<span>;<br /></span><span>    if </span>(input == <span>null</span>) {<br /><span>      return;<br /></span>    }<br /><br /><span>    // Loop through available map-outputs and fetch them<br /></span><span>    // On any error, faildTasks is not null and we exit<br /></span><span>    // after putting back the remaining maps to the <br /></span><span>    // yet_to_be_fetched list and marking the failed tasks.<br /></span>    TaskAttemptID[] failedTasks = <span>null;<br /></span><span>    while </span>(!remaining.isEmpty() &amp;&amp; failedTasks == <span>null</span>) {<br /><span>      try </span>{<br />        <b>failedTasks = copyMapOutput(host<span>, </span>input<span>, </span>remaining<span>, </span>fetchRetryEnabled)</b><span><b>;</b><br /></span>      } <span>catch </span>(IOException e) {<br />        IOUtils.cleanupWithLogger(LOG<span>, </span>input)<span>;<br /></span><span>        //<br /></span><span>        // Setup connection again if disconnected by NM<br /></span>        connection.disconnect()<span>;<br /></span><span>        // Get map output from remaining tasks only.<br /></span>        url = getMapOutputURL(host<span>, </span>remaining)<span>;<br /></span>        input = openShuffleUrl(host<span>, </span>remaining<span>, </span>url)<span>;<br /></span><span>        if </span>(input == <span>null</span>) {<br /><span>          return;<br /></span>        }<br />      }<br />    }<br /><br /><span>    if</span>(failedTasks != <span>null </span>&amp;&amp; failedTasks.length &gt; <span>0</span>) {<br />      LOG.warn(<span>"copyMapOutput failed for tasks "</span>+Arrays.toString(failedTasks))<span>;<br /></span>      scheduler.hostFailed(host.getHostName())<span>;<br /></span><span>      for</span>(TaskAttemptID left: failedTasks) {<br />        scheduler.copyFailed(left<span>, </span>host<span>, true, false</span>)<span>;<br /></span>      }<br />    }<br /><br /><span>    // Sanity check<br /></span><span>    if </span>(failedTasks == <span>null </span>&amp;&amp; !remaining.isEmpty()) {<br /><span>      throw new </span>IOException(<span>"server didn't return all expected map outputs: "<br /></span>                           + remaining.size() + <span>" left."</span>)<span>;<br /></span>    }<br />    input.close()<span>;<br /></span>    input = <span>null;<br /></span>  } <span>finally </span>{<br /><span>    if </span>(input != <span>null</span>) {<br />      IOUtils.cleanupWithLogger(LOG<span>, </span>input)<span>;<br /></span>      input = <span>null;<br /></span>    }<br /><span>    for </span>(TaskAttemptID left : remaining) {<br />      scheduler.putBackKnownMapOutput(host<span>, </span>left)<span>;<br /></span>    }<br />  }<br />}</pre></pre></pre></div></div></foreignObject><text x="285" y="586" fill="#333333" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><path d="M 2690.18 1699.07 L 2428.23 2246.78" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/><rect x="3502" y="3109" width="530" height="610" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(3506.5,3098.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="497" height="615" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 615px; max-width: 515px; width: 498px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>ShuffleSchedulerImpl.java</h1><pre><pre><pre><pre><pre><pre><span>public synchronized void </span>copySucceeded(TaskAttemptID mapId<span>,<br /></span>                                       MapHost host<span>,<br /></span><span>                                       long </span>bytes<span>,<br /></span><span>                                       long </span>startMillis<span>,<br /></span><span>                                       long </span>endMillis<span>,<br /></span>                                       MapOutput&lt;K<span>,</span>V&gt; output<br />                                       ) <span>throws </span>IOException {<br />  failureCounts.remove(mapId)<span>;<br /></span>  hostFailures.remove(host.getHostName())<span>;<br /></span><span>  int </span>mapIndex = mapId.getTaskID().getId()<span>;<br /></span><span><br /></span><span>  if </span>(!finishedMaps[mapIndex]) {<br /><b>    output.commit()<span>;<br /></span></b>    finishedMaps[mapIndex] = <span>true;<br /></span>    shuffledMapsCounter.increment(<span>1</span>)<span>;<br /></span><span>    if </span>(--remainingMaps == <span>0</span>) {<br />      notifyAll()<span>;<br /></span>    }<br /><br /><span>    // update single copy task status<br /></span><span>    long </span>copyMillis = (endMillis - startMillis)<span>;<br /></span><span>    if </span>(copyMillis == <span>0</span>) copyMillis = <span>1</span><span>;<br /></span><span>    float </span>bytesPerMillis = (<span>float</span>) bytes / copyMillis<span>;<br /></span><span>    float </span>transferRate = bytesPerMillis * BYTES_PER_MILLIS_TO_MBS<span>;<br /></span>    String individualProgress = <span>"copy task(" </span>+ mapId + <span>" succeeded"<br /></span>               + <span>" at " </span>+ mbpsFormat.format(transferRate) + <span>" MB/s)"</span><span>;<br /></span><span>    // update the aggregated status<br /></span>    copyTimeTracker.add(startMillis<span>, </span>endMillis)<span>;<br /></span><span><br /></span>    totalBytesShuffledTillNow += bytes<span>;<br /></span>    updateStatus(individualProgress)<span>;<br /></span>    reduceShuffleBytes.increment(bytes)<span>;<br /></span>    lastProgressTime = Time.monotonicNow()<span>;<br /></span>    LOG.debug(<span>"map " </span>+ mapId + <span>" done " </span>+ status.getStateString())<span>;<br /></span>  } <span>else </span>{<br />    LOG.warn(<span>"Aborting already-finished MapOutput for " </span>+ mapId)<span>;<br /></span>    output.abort()<span>;<br /></span>  }<br />}</pre></pre></pre></pre></pre></pre></div></div></foreignObject><text x="249" y="314" fill="#333333" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><path d="M 3499.84 3165.98 L 3120 2819" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/><rect x="4110" y="3119" width="340" height="120" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(4114.5,3108.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="295" height="125" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 125px; max-width: 325px; width: 296px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>InMemoryMapOutput.java</h1><pre><pre><pre><pre><pre><pre><pre>@Override<br /><span>public void </span>commit() <span>throws </span>IOException {<br /><b>  getMerger().closeInMemoryFile(<span>this</span>)<span>;<br /></span></b>}</pre></pre></pre></pre></pre></pre></pre></div></div></foreignObject><text x="148" y="69" fill="#333333" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><path d="M 4109.46 3180.27 L 3660 3329" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/><path d="M 4614.31 3032.62 L 4390.46 3208.84" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/><rect x="4107" y="3429" width="533" height="160" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(4111.5,3418.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="518" height="165" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 165px; max-width: 518px; width: 518.237px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>OnDiskMapOutput.java</h1><pre><pre><pre><pre><pre><pre><pre><pre>@Override<br /><span>public void </span>commit() <span>throws </span>IOException {<br />  fs.rename(tmpOutputPath<span>, </span>outputPath)<span>;<br /></span>  CompressAwarePath compressAwarePath = <span>new </span>CompressAwarePath(outputPath<span>,<br /></span>    getSize()<span>, this</span>.compressedSize)<span>;<br /></span><b>  getMerger().closeOnDiskFile(compressAwarePath)<span>;<br /></span></b>}</pre></pre></pre></pre></pre></pre></pre></pre></div></div></foreignObject><text x="259" y="89" fill="#333333" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><path d="M 4104.7 3499.37 L 3660 3339" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/><rect x="4715" y="3429" width="500" height="160" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(4719.5,3418.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="475" height="165" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 165px; max-width: 485px; width: 476px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>MergeManagerImpl.java</h1><pre><pre><pre><pre><pre><pre><pre><pre><pre><span>public synchronized void </span>closeOnDiskFile(CompressAwarePath file) {<br />  onDiskMapOutputs.add(file)<span>;<br /></span><span><br /></span><span>  if </span>(onDiskMapOutputs.size() &gt;= (<span>2 </span>* ioSortFactor - <span>1</span>)) {<br />    onDiskMerger.startMerge(onDiskMapOutputs)<span>;<br /></span>  }<br />}</pre></pre></pre></pre></pre></pre></pre></pre></pre></div></div></foreignObject><text x="238" y="89" fill="#333333" text-anchor="middle" font-size="12px" font-family="Helvetica">[Not supported by viewer]</text></switch></g><path d="M 4719.09 3489.84 L 4461.9 3561.28" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/></g></svg>