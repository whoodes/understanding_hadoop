<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="5482px" height="4301px" viewBox="-0.5 -0.5 5482 4301" content="&lt;mxfile modified=&quot;2019-06-29T00:24:35.744Z&quot; host=&quot;www.draw.io&quot; agent=&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36&quot; version=&quot;10.8.3&quot; etag=&quot;EVU5ZAqWasnDyk_Voy6f&quot; type=&quot;device&quot;&gt;&lt;diagram id=&quot;wb7UtgkJbHnFSIjihnlT&quot;&gt;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&lt;/diagram&gt;&lt;/mxfile&gt;"><defs/><g><rect x="0" y="10" width="730" height="1230" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(4.5,-0.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="713" height="1239" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 1239px; max-width: 719px; width: 714px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>ReduceTask.java</h1><pre>@Override<br />@SuppressWarnings(<span>"unchecked"</span>)<br /><span>public void </span>run(JobConf job<span>, final </span>TaskUmbilicalProtocol umbilical)<br /><span>throws </span>IOException<span>, </span>InterruptedException<span>, </span>ClassNotFoundException {<br />  job.setBoolean(JobContext.SKIP_RECORDS<span>, </span>isSkipping())<span>;<br /></span><span><br /></span><span>  if </span>(isMapOrReduce()) {<br />    copyPhase = getProgress().addPhase(<span>"copy"</span>)<span>;<br /></span>    sortPhase  = getProgress().addPhase(<span>"sort"</span>)<span>;<br /></span>    reducePhase = getProgress().addPhase(<span>"reduce"</span>)<span>;<br /></span>  }</pre><pre><br /><span>  // start thread that will handle communication with parent<br /></span>  TaskReporter reporter = startReporter(umbilical)<span>;<br /></span><span><br /></span><span>  boolean </span>useNewApi = job.getUseNewReducer()<span>;<br /></span>  initialize(job<span>, </span>getJobID()<span>, </span>reporter<span>, </span>useNewApi)<span>;<br /></span><span><br /></span><span>  // check if it is a cleanupJobTask<br /></span><span>  if </span>(jobCleanup) {<br />    runJobCleanupTask(umbilical<span>, </span>reporter)<span>;<br /></span><span>    return;<br /></span>  }<br /><span>  if </span>(jobSetup) {<br />    runJobSetupTask(umbilical<span>, </span>reporter)<span>;<br /></span><span>    return;<br /></span>  }<br /><span>  if </span>(taskCleanup) {<br />    runTaskCleanupTask(umbilical<span>, </span>reporter)<span>;<br /></span><span>    return;<br /></span>  }<br /><br /><span>  // Initialize the codec<br /></span>  codec = initCodec()<span>;<br /></span>  RawKeyValueIterator rIter = <span>null;<br /></span>  ShuffleConsumerPlugin shuffleConsumerPlugin = <span>null;<br /></span><span><br /></span>  Class combinerClass = conf.getCombinerClass()<span>;<br /></span>  CombineOutputCollector combineCollector = <br />    (<span>null </span>!= combinerClass) ? <br /><span>    new </span>CombineOutputCollector(reduceCombineOutputCounter<span>, </span>reporter<span>, </span>conf) : <span>null;<br /></span><span><br /></span>  Class&lt;? <span>extends </span>ShuffleConsumerPlugin&gt; clazz =<br />        job.getClass(MRConfig.SHUFFLE_CONSUMER_PLUGIN<span>, </span>Shuffle.<span>class, </span>ShuffleConsumerPlugin.<span>class</span>)<span>;<br /></span><span><br /></span>  shuffleConsumerPlugin = ReflectionUtils.newInstance(clazz<span>, </span>job)<span>;<br /></span>  LOG.info(<span>"Using ShuffleConsumerPlugin: " </span>+ shuffleConsumerPlugin)<span>;<br /></span><span><br /></span>  ShuffleConsumerPlugin.Context shuffleContext = <br /><span>  new </span>ShuffleConsumerPlugin.Context(getTaskID()<span>, </span>job<span>, </span>FileSystem.getLocal(job)<span>, </span>umbilical<span>, <br /></span><span>                super</span>.lDirAlloc<span>, </span>reporter<span>, </span>codec<span>, <br /></span>                combinerClass<span>, </span>combineCollector<span>, <br /></span>                spilledRecordsCounter<span>, </span>reduceCombineInputCounter<span>,<br /></span>                shuffledMapsCounter<span>,<br /></span>                reduceShuffleBytes<span>, </span>failedShuffleCounter<span>,<br /></span>                mergedMapOutputsCounter<span>,<br /></span>                taskStatus<span>, </span>copyPhase<span>, </span>sortPhase<span>, this,<br /></span>                mapOutputFile<span>, </span>localMapFiles)<span>;<br /></span><b><font color="#000000">  shuffleConsumerPlugin.init(shuffleContext);<br /></font></b><span><br /></span><b>  rIter = shuffleConsumerPlugin.run()<span>;<br /></span></b><span><br /></span><span>  // free up the data structures<br /></span>  mapOutputFilesOnDisk.clear()<span>;<br /></span><span><br /></span>  sortPhase.complete()<span>;                         </span><span>// sort is complete<br /></span>  setPhase(TaskStatus.Phase.REDUCE)<span>; <br /></span>  statusUpdate(umbilical)<span>;<br /></span>  Class keyClass = job.getMapOutputKeyClass()<span>;<br /></span>  Class valueClass = job.getMapOutputValueClass()<span>;<br /></span>  RawComparator comparator = job.getOutputValueGroupingComparator()<span>;<br /></span><span><br /></span><span>  if </span>(useNewApi) {<br />    runNewReducer(job<span>, </span>umbilical<span>, </span>reporter<span>, </span>rIter<span>, </span>comparator<span>, <br /></span>    keyClass<span>, </span>valueClass)<span>;<br /></span>  } <span>else </span>{<br />    runOldReducer(job<span>, </span>umbilical<span>, </span>reporter<span>, </span>rIter<span>, </span>comparator<span>,  <br /></span>  keyClass<span>, </span>valueClass)<span>;<br /></span>  }<br /><br />  shuffleConsumerPlugin.close()<span>;<br /></span>  done(umbilical<span>, </span>reporter)<span>;</span><span><br /></span>}</pre></div></div></foreignObject><text x="357" y="625" fill="#333333" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><rect x="790" y="70" width="560" height="370" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(794.5,59.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="540" height="350" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 379px; max-width: 549px; width: 541px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>Shuffle.java</h1><pre>@Override<br /><span>public void </span>init(ShuffleConsumerPlugin.Context context) {<br /><span>  this</span>.context = context<span>;<br /></span><span><br /></span><span>  this</span>.reduceId = context.getReduceId()<span>;<br /></span><span>  this</span>.jobConf = context.getJobConf()<span>;<br /></span><span>  this</span>.umbilical = context.getUmbilical()<span>;<br /></span><span>  this</span>.reporter = context.getReporter()<span>;<br /></span><span>  this</span>.metrics = ShuffleClientMetrics.create(context.getReduceId()<span>,<br /></span><span>      this</span>.jobConf)<span>;<br /></span><span>  this</span>.copyPhase = context.getCopyPhase()<span>;<br /></span><span>  this</span>.taskStatus = context.getStatus()<span>;<br /></span><span>  this</span>.reduceTask = context.getReduceTask()<span>;<br /></span><span>  this</span>.localMapFiles = context.getLocalMapFiles()<span>;<br /></span><span><br /></span>  scheduler = <span>new </span>ShuffleSchedulerImpl&lt;K<span>, </span>V&gt;(jobConf<span>, </span>taskStatus<span>, </span>reduceId<span>,<br /></span><span>      this, </span>copyPhase<span>, </span>context.getShuffledMapsCounter()<span>,<br /></span>      context.getReduceShuffleBytes()<span>, </span>context.getFailedShuffleCounter())<span>;<br /></span><b>  merger = createMergeManager(context)<span>;<br /></span></b>}</pre></div></div></foreignObject><text x="270" y="181" fill="#333333" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><path d="M 330 889 L 784.1 149.71" fill="none" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 786.84 145.24 L 786.16 153.03 L 784.1 149.71 L 780.2 149.37 Z" fill="#82b366" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 791.71 401.43 L 334.37 885.37" fill="none" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 330.77 889.19 L 333.03 881.7 L 334.37 885.37 L 338.12 886.5 Z" fill="#6c8ebf" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><rect x="1450" y="145" width="560" height="220" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(1454.5,134.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="547" height="210" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 229px; max-width: 549px; width: 548px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>Shuffle.java</h1><pre><pre>protected MergeManager&lt;K, V&gt; createMergeManager(<br />    ShuffleConsumerPlugin.Context context) {<br />  return <b>new </b><b>MergeManagerImpl&lt;K<span>, </span>V&gt;(reduceId<span>, </span>jobConf<span>, </span>context.getLocalFS()<span>,<br /></span>    context.getLocalDirAllocator()<span>, </span>reporter<span>, </span>context.getCodec()<span>,<br /></span>    context.getCombinerClass()<span>, </span>context.getCombineCollector()<span>, <br /></span>    context.getSpilledRecordsCounter()<span>,<br /></span>    context.getReduceCombineInputCounter()<span>,<br /></span>    context.getMergedMapOutputsCounter()<span>, this, </span>context.getMergePhase()<span>,<br /></span>    context.getMapOutputFile())</b><b>;</b><br />}</pre></pre></div></div></foreignObject><text x="274" y="111" fill="#333333" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><path d="M 1080.29 380 L 1444.56 202.79" fill="none" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 1449.28 200.49 L 1444.52 206.7 L 1444.56 202.79 L 1441.45 200.4 Z" fill="#82b366" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 1447.43 338.57 L 1086.31 389.12" fill="none" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 1081.11 389.85 L 1087.55 385.41 L 1086.31 389.12 L 1088.52 392.34 Z" fill="#6c8ebf" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><rect x="2110" y="10" width="620" height="1560" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(2114.5,-0.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="562" height="1552" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 1569px; max-width: 609px; width: 563px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>MergeManagerImpl.java</h1><pre><pre><pre><span>public </span>MergeManagerImpl(TaskAttemptID reduceId<span>, </span>JobConf jobConf<span>, <br /></span>            FileSystem localFS<span>,<br /></span>            LocalDirAllocator localDirAllocator<span>,  <br /></span>            Reporter reporter<span>,<br /></span>            CompressionCodec codec<span>,<br /></span>            Class&lt;? <span>extends </span>Reducer&gt; combinerClass<span>,<br /></span>            CombineOutputCollector&lt;K<span>,</span>V&gt; combineCollector<span>,<br /></span>            Counters.Counter spilledRecordsCounter<span>,<br /></span>            Counters.Counter reduceCombineInputCounter<span>,<br /></span>            Counters.Counter mergedMapOutputsCounter<span>,<br /></span>            ExceptionReporter exceptionReporter<span>,<br /></span>            Progress mergePhase<span>, </span>MapOutputFile mapOutputFile) {<br /><span>  this</span>.reduceId = reduceId<span>;<br /></span><span>  this</span>.jobConf = jobConf<span>;<br /></span><span>  this</span>.localDirAllocator = localDirAllocator<span>;<br /></span><span>  this</span>.exceptionReporter = exceptionReporter<span>;<br /></span><span><br /></span><span>  this</span>.reporter = reporter<span>;<br /></span><span>  this</span>.codec = codec<span>;<br /></span><span>  this</span>.combinerClass = combinerClass<span>;<br /></span><span>  this</span>.combineCollector = combineCollector<span>;<br /></span><span>  this</span>.reduceCombineInputCounter = reduceCombineInputCounter<span>;<br /></span><span>  this</span>.spilledRecordsCounter = spilledRecordsCounter<span>;<br /></span><span>  this</span>.mergedMapOutputsCounter = mergedMapOutputsCounter<span>;<br /></span><span>  this</span>.mapOutputFile = mapOutputFile<span>;<br /></span><span>  this</span>.mapOutputFile.setConf(jobConf)<span>;<br /></span><span><br /></span><span>  this</span>.localFS = localFS<span>;<br /></span><span>  this</span>.rfs = ((LocalFileSystem)localFS).getRaw()<span>;<br /></span><span><br /></span><span>  final float </span>maxInMemCopyUse =<br />    jobConf.getFloat(MRJobConfig.SHUFFLE_INPUT_BUFFER_PERCENT<span>,<br /></span>      MRJobConfig.DEFAULT_SHUFFLE_INPUT_BUFFER_PERCENT)<span>;<br /></span><span>  if </span>(maxInMemCopyUse &gt; <span>1.0 </span>|| maxInMemCopyUse &lt; <span>0.0</span>) {<br /><span>    throw new </span>IllegalArgumentException(<span>"Invalid value for " </span>+<br />        MRJobConfig.SHUFFLE_INPUT_BUFFER_PERCENT + <span>": " </span>+<br />        maxInMemCopyUse)<span>;<br /></span>  }<br /><br /><span>  // Allow unit tests to fix Runtime memory<br /></span><span>  this</span>.memoryLimit = (<span>long</span>)(jobConf.getLong(<br />      MRJobConfig.REDUCE_MEMORY_TOTAL_BYTES<span>,<br /></span>      Runtime.getRuntime().maxMemory()) * maxInMemCopyUse)<span>;</span></pre><pre><span><br /></span><span>  this</span>.ioSortFactor = jobConf.getInt(MRJobConfig.IO_SORT_FACTOR<span>,<br /></span>    MRJobConfig.DEFAULT_IO_SORT_FACTOR)<span>;<br /></span><span><br /></span><span>  final float </span>singleShuffleMemoryLimitPercent =<br />      jobConf.getFloat(MRJobConfig.SHUFFLE_MEMORY_LIMIT_PERCENT<span>,<br /></span>      DEFAULT_SHUFFLE_MEMORY_LIMIT_PERCENT)<span>;<br /></span><span>  if </span>(singleShuffleMemoryLimitPercent &lt; <span>0.0f<br /></span>    || singleShuffleMemoryLimitPercent &gt; <span>1.0f</span>) {<br /><span>       throw new </span>IllegalArgumentException(<span>"Invalid value for "<br /></span>         + MRJobConfig.SHUFFLE_MEMORY_LIMIT_PERCENT + <span>": "<br /></span>         + singleShuffleMemoryLimitPercent)<span>;<br /></span>  }<br /><br />  usedMemory = <span>0L</span><span>;<br /></span>  commitMemory = <span>0L</span><span>;<br /></span><span>  long </span>maxSingleShuffleLimitConfiged =<br />      (<span>long</span>)(memoryLimit * singleShuffleMemoryLimitPercent)<span>;<br /></span><span>  if</span>(maxSingleShuffleLimitConfiged &gt; Integer.MAX_VALUE) {<br />    maxSingleShuffleLimitConfiged = Integer.MAX_VALUE<span>;<br /></span>    LOG.info(<span>"The max number of bytes for a single in-memory shuffle cannot" </span>+<br /><span>      " be larger than Integer.MAX_VALUE. Setting it to Integer.MAX_VALUE"</span>)<span>;<br /></span>  }<br /><span>  this</span>.maxSingleShuffleLimit = maxSingleShuffleLimitConfiged<span>;<br /></span><span>  this</span>.memToMemMergeOutputsThreshold =<br />      jobConf.getInt(MRJobConfig.REDUCE_MEMTOMEM_THRESHOLD<span>, </span>ioSortFactor)<span>;<br /></span><span>  this</span>.mergeThreshold = (<span>long</span>)(<span>this</span>.memoryLimit * <br />                        jobConf.getFloat(<br />                          MRJobConfig.SHUFFLE_MERGE_PERCENT<span>,<br /></span>                          MRJobConfig.DEFAULT_SHUFFLE_MERGE_PERCENT))<span>;<br /></span>  LOG.info(<span>"MergerManager: memoryLimit=" </span>+ memoryLimit + <span>", " </span>+<br /><span>           "maxSingleShuffleLimit=" </span>+ maxSingleShuffleLimit + <span>", " </span>+<br /><span>           "mergeThreshold=" </span>+ mergeThreshold + <span>", " </span>+ <br /><span>           "ioSortFactor=" </span>+ ioSortFactor + <span>", " </span>+<br /><span>           "memToMemMergeOutputsThreshold=" </span>+ memToMemMergeOutputsThreshold)<span>;<br /></span><span><br /></span><span>  if </span>(<span>this</span>.maxSingleShuffleLimit &gt;= <span>this</span>.mergeThreshold) {<br /><span>    throw new </span>RuntimeException(<span>"Invalid configuration: "<br /></span>      + <span>"maxSingleShuffleLimit should be less than mergeThreshold "<br /></span>      + <span>"maxSingleShuffleLimit: " </span>+ <span>this</span>.maxSingleShuffleLimit<br />      + <span>"mergeThreshold: " </span>+ <span>this</span>.mergeThreshold)<span>;<br /></span>  }<br /><br /><span>  boolean </span>allowMemToMemMerge = <br />    jobConf.getBoolean(MRJobConfig.REDUCE_MEMTOMEM_ENABLED<span>, false</span>)<span>;<br /></span><span>    if </span>(allowMemToMemMerge) {<br /><span>      this</span>.memToMemMerger = <br /><span>        new </span>IntermediateMemoryToMemoryMerger(<span>this,<br /></span>                                             memToMemMergeOutputsThreshold)<span>;<br /></span><span>      this</span>.memToMemMerger.start()<span>;<br /></span>  } <span>else </span>{<br /><span>    this</span>.memToMemMerger = <span>null;<br /></span>  }<br /><br /><span>  this</span>.inMemoryMerger = createInMemoryMerger()<span>;<br /></span><b><span>  this</span>.inMemoryMerger.start()<span>;<br /></span></b><span><br /></span><span>  this</span>.onDiskMerger = <span>new </span>OnDiskMerger(<span>this</span>)<span>;<br /></span><b><span>  this</span>.onDiskMerger.start()<span>;<br /></span></b><span><br /></span><span>  this</span>.mergePhase = mergePhase<span>;<br /></span>}</pre></pre></pre></div></div></foreignObject><text x="281" y="782" fill="#333333" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><path d="M 2010.29 230 L 2105.58 71.17" fill="none" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 2108.28 66.67 L 2107.68 74.48 L 2105.58 71.17 L 2101.68 70.87 Z" fill="#82b366" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 2108.86 1534.29 L 2010.8 316.35" fill="none" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 2010.38 311.11 L 2014.43 317.81 L 2010.8 316.35 L 2007.45 318.37 Z" fill="#6c8ebf" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><rect x="2830" y="10" width="450" height="490" fill="#e1d5e7" stroke="#9673a6" pointer-events="none"/><g transform="translate(2834.5,-0.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="374" height="490" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 499px; max-width: 439px; width: 375px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>MergeThread.java</h1><pre><pre><pre><pre><span>public void </span>run() {<br /><span>  while </span>(<span>true</span>) {<br />    List&lt;T&gt; inputs = <span>null;<br /></span><span>    try </span>{<br /><span>      // Wait for notification to start the merge...<br /></span><span>      synchronized </span>(pendingToBeMerged) {<br /><span>        while</span>(pendingToBeMerged.size() &lt;= <span>0</span>) {<br />          pendingToBeMerged.wait()<span>;<br /></span>        }<br /><span>        // Pickup the inputs to merge.<br /></span>        inputs = pendingToBeMerged.removeFirst()<span>;<br /></span>      }<br /><br /><span>      // Merge<br /></span>      <b>merge(inputs)<span>;<br /></span> </b>   } <span>catch </span>(InterruptedException ie) {<br />      numPending.set(<span>0</span>)<span>;<br /></span><span>      return;<br /></span>    } <span>catch</span>(Throwable t) {<br />      numPending.set(<span>0</span>)<span>;<br /></span>      reporter.reportException(t)<span>;<br /></span><span>      return;<br /></span>    } <span>finally </span>{<br /><span>      synchronized </span>(<span>this</span>) {<br />        numPending.decrementAndGet()<span>;<br /></span>        notifyAll()<span>;<br /></span>      }<br />    }<br />  }<br />}</pre></pre></pre></pre></div></div></foreignObject><text x="187" y="251" fill="#000000" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><path d="M 2330 1450 L 2826.69 74.56" fill="none" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 2828.48 69.62 L 2829.39 77.4 L 2826.69 74.56 L 2822.81 75.02 Z" fill="#82b366" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 2320 1490 L 2827 646.89" fill="none" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 2829.71 642.39 L 2829.1 650.19 L 2827 646.89 L 2823.1 646.58 Z" fill="#82b366" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 2830.29 475.71 L 2332.92 1440.34" fill="none" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 2330.51 1445.01 L 2330.61 1437.18 L 2332.92 1440.34 L 2336.83 1440.39 Z" fill="#6c8ebf" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 2830.29 1050 L 2324.82 1485.84" fill="none" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 2320.85 1489.27 L 2323.86 1482.05 L 2324.82 1485.84 L 2328.43 1487.35 Z" fill="#6c8ebf" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><rect x="2830" y="580" width="450" height="490" fill="#e1d5e7" stroke="#9673a6" pointer-events="none"/><g transform="translate(2834.5,569.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="374" height="490" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 499px; max-width: 439px; width: 375px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>MergeThread.java</h1><pre><pre><pre><pre><span>public void </span>run() {<br /><span>  while </span>(<span>true</span>) {<br />    List&lt;T&gt; inputs = <span>null;<br /></span><span>    try </span>{<br /><span>      // Wait for notification to start the merge...<br /></span><span>      synchronized </span>(pendingToBeMerged) {<br /><span>        while</span>(pendingToBeMerged.size() &lt;= <span>0</span>) {<br />          pendingToBeMerged.wait()<span>;<br /></span>        }<br /><span>        // Pickup the inputs to merge.<br /></span>        inputs = pendingToBeMerged.removeFirst()<span>;<br /></span>      }<br /><br /><span>      // Merge<br /></span>      <b>merge(inputs)</b><span><b>;</b><br /></span>    } <span>catch </span>(InterruptedException ie) {<br />      numPending.set(<span>0</span>)<span>;<br /></span><span>      return;<br /></span>    } <span>catch</span>(Throwable t) {<br />      numPending.set(<span>0</span>)<span>;<br /></span>      reporter.reportException(t)<span>;<br /></span><span>      return;<br /></span>    } <span>finally </span>{<br /><span>      synchronized </span>(<span>this</span>) {<br />        numPending.decrementAndGet()<span>;<br /></span>        notifyAll()<span>;<br /></span>      }<br />    }<br />  }<br />}</pre></pre></pre></pre></div></div></foreignObject><text x="187" y="251" fill="#000000" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><rect x="3500" y="10" width="660" height="1180" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(3504.5,-0.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="648" height="1189" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 1189px; max-width: 649px; width: 648.571px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>MergeManagerImpl.java</h1><pre><pre><pre><pre><span>private class </span>InMemoryMerger <span>extends </span>MergeThread&lt;InMemoryMapOutput&lt;K<span>,</span>V&gt;<span>, </span>K<span>,</span>V&gt; {<br /><br /><span>  public </span>InMemoryMerger(MergeManagerImpl&lt;K<span>, </span>V&gt; manager) {<br /><span>    super</span>(manager<span>, </span>Integer.MAX_VALUE<span>, </span>exceptionReporter)<span>;<br /></span>    setName<br />    (<span>"InMemoryMerger - Thread to merge in-memory shuffled map-outputs"</span>)<span>;<br /></span>    setDaemon(<span>true</span>)<span>;<br /></span>}<br /><br />  @Override<br /><span>  public void </span>merge(List&lt;InMemoryMapOutput&lt;K<span>,</span>V&gt;&gt; inputs) <span>throws </span>IOException {<br /><span>    if </span>(inputs == <span>null </span>|| inputs.size() == <span>0</span>) {<br /><span>      return;<br /></span>    }<br /><br /><span>    //name this output file same as the name of the first file that is <br /></span><span>    //there in the current list of inmem files (this is guaranteed to<br /></span><span>    //be absent on the disk currently. So we don't overwrite a prev. <br /></span><span>    //created spill). Also we need to create the output file now since<br /></span><span>    //it is not guaranteed that this file will be present after merge<br /></span><span>    //is called (we delete empty files as soon as we see them<br /></span><span>    //in the merge method)<br /></span><span><br /></span><span>    //figure out the mapId <br /></span>    TaskAttemptID mapId = inputs.get(<span>0</span>).getMapId()<span>;<br /></span>    TaskID mapTaskId = mapId.getTaskID()<span>;<br /></span><span><br /></span>    List&lt;Segment&lt;K<span>, </span>V&gt;&gt; inMemorySegments = <span>new </span>ArrayList&lt;Segment&lt;K<span>, </span>V&gt;&gt;()<span>;<br /></span><span>    long </span>mergeOutputSize = createInMemorySegments(inputs<span>, </span>inMemorySegments<span>,</span><span>0</span>)<span>;<br /></span><span>    int </span>noInMemorySegments = inMemorySegments.size()<span>;<br /></span><span><br /></span>    Path outputPath = mapOutputFile.getInputFileForWrite(mapTaskId<span>,<br /></span>                    mergeOutputSize).suffix(<br />                                     Task.MERGED_OUTPUT_PREFIX)<span>;<br /></span><span><br /></span>    FSDataOutputStream out = CryptoUtils.wrapIfNecessary(jobConf<span>, </span>rfs.create(outputPath))<span>;<br /></span>    Writer&lt;K<span>, </span>V&gt; writer = <span>new </span>Writer&lt;K<span>, </span>V&gt;(jobConf<span>, </span>out<span>,<br /></span>      (Class&lt;K&gt;) jobConf.getMapOutputKeyClass()<span>,<br /></span>      (Class&lt;V&gt;) jobConf.getMapOutputValueClass()<span>, </span>codec<span>, null, true</span>)<span>;<br /></span><span><br /></span>    RawKeyValueIterator rIter = <span>null;<br /></span>    CompressAwarePath compressAwarePath<span>;<br /></span><span>    try </span>{<br />      LOG.info(<span>"Initiating in-memory merge with " </span>+ noInMemorySegments + <br /><span>               " segments..."</span>)<span>;<br /></span><span><br /></span>      rIter = <b>Merger.merge(jobConf<span>, </span>rfs<span>,<br /></span>                          (Class&lt;K&gt;)jobConf.getMapOutputKeyClass()<span>,<br /></span>                          (Class&lt;V&gt;)jobConf.getMapOutputValueClass()<span>,<br /></span>                           inMemorySegments<span>, </span>inMemorySegments.size()<span>,<br /></span><span>                           new </span>Path(reduceId.toString())<span>,<br /></span>                          (RawComparator&lt;K&gt;)jobConf.getOutputKeyComparator()<span>,<br /></span>                           reporter<span>, </span>spilledRecordsCounter<span>, null, null</span>)</b><span><b>;</b><br /></span><span><br /></span><span>      if </span>(<span>null </span>== combinerClass) {<br />        Merger.writeFile(rIter<span>, </span>writer<span>, </span>reporter<span>, </span>jobConf)<span>;<br /></span>      } <span>else </span>{<br />        combineCollector.setWriter(writer)<span>;<br /></span>        combineAndSpill(rIter<span>, </span>reduceCombineInputCounter)<span>;<br /></span>      }<br />      writer.close()<span>;<br /></span>      compressAwarePath = <span>new </span>CompressAwarePath(outputPath<span>,<br /></span>      writer.getRawLength()<span>, </span>writer.getCompressedLength())<span>;<br /></span><span><br /></span>      LOG.info(reduceId +  <br /><span>               " Merge of the " </span>+ noInMemorySegments +<br /><span>               " files in-memory complete." </span>+<br /><span>               " Local file is " </span>+ outputPath + <span>" of size " </span>+ <br />               localFS.getFileStatus(outputPath).getLen())<span>;<br /></span>    } <span>catch </span>(IOException e) { <br /><span>      //make sure that we delete the ondisk file that we created <br /></span><span>      //earlier when we invoked cloneFileAttributes<br /></span>      localFS.delete(outputPath<span>, true</span>)<span>;<br /></span><span>      throw </span>e<span>;<br /></span>    }<br /><br /><span>    // Note the output of the merge<br /></span>    closeOnDiskFile(compressAwarePath)<span>;<br /></span>  }<br />}</pre></pre></pre></pre></div></div></foreignObject><text x="324" y="600" fill="#333333" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><path d="M 2980.29 260 L 3497.43 207.14" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/><rect x="3500" y="1220" width="660" height="1100" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(3504.5,1209.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="648" height="1106" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 1109px; max-width: 649px; width: 648.571px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>MergeManagerImpl.java</h1><pre><pre><pre><pre><pre><span>private class </span>OnDiskMerger <span>extends </span>MergeThread&lt;CompressAwarePath<span>,</span>K<span>,</span>V&gt; {<br /><br /><span>  public </span>OnDiskMerger(MergeManagerImpl&lt;K<span>, </span>V&gt; manager) {<br /><span>    super</span>(manager<span>, </span>ioSortFactor<span>, </span>exceptionReporter)<span>;<br /></span>    setName(<span>"OnDiskMerger - Thread to merge on-disk map-outputs"</span>)<span>;<br /></span>    setDaemon(<span>true</span>)<span>;<br /></span>  }<br /><br />  @Override<br /><span>  public void </span>merge(List&lt;CompressAwarePath&gt; inputs) <span>throws </span>IOException {<br /><span>    // sanity check<br /></span><span>    if </span>(inputs == <span>null </span>|| inputs.isEmpty()) {<br />      LOG.info(<span>"No ondisk files to merge..."</span>)<span>;<br /></span><span>      return;<br /></span>    }<br /><br /><span>    long </span>approxOutputSize = <span>0</span><span>;<br /></span><span>    int </span>bytesPerSum = <br />      jobConf.getInt(<span>"io.bytes.per.checksum"</span><span>, </span><span>512</span>)<span>;<br /></span><span><br /></span>    LOG.info(<span>"OnDiskMerger: We have  " </span>+ inputs.size() + <br /><span>             " map outputs on disk. Triggering merge..."</span>)<span>;<br /></span><span><br /></span><span>    // 1. Prepare the list of files to be merged. <br /></span><span>    for </span>(CompressAwarePath file : inputs) {<br />      approxOutputSize += localFS.getFileStatus(file).getLen()<span>;<br /></span>    }<br /><br /><span>    // add the checksum length<br /></span>    approxOutputSize += <br />      ChecksumFileSystem.getChecksumLength(approxOutputSize<span>, </span>bytesPerSum)<span>;<br /></span><span><br /></span><span>    // 2. Start the on-disk merge process<br /></span>    Path outputPath = <br />      localDirAllocator.getLocalPathForWrite(inputs.get(<span>0</span>).toString()<span>, <br /></span>        approxOutputSize<span>, </span>jobConf).suffix(Task.MERGED_OUTPUT_PREFIX)<span>;<br /></span><span><br /></span>    FSDataOutputStream out = CryptoUtils.wrapIfNecessary(jobConf<span>, </span>rfs.create(outputPath))<span>;<br /></span>    Writer&lt;K<span>, </span>V&gt; writer = <span>new </span>Writer&lt;K<span>, </span>V&gt;(jobConf<span>, </span>out<span>,<br /></span>                         (Class&lt;K&gt;) jobConf.getMapOutputKeyClass()<span>,<br /></span>                         (Class&lt;V&gt;) jobConf.getMapOutputValueClass()<span>, </span>codec<span>, null, true</span>)<span>;<br /></span><span><br /></span>    RawKeyValueIterator iter  = <span>null;<br /></span>    CompressAwarePath compressAwarePath<span>;<br /></span>    Path tmpDir = <span>new </span>Path(reduceId.toString())<span>;<br /></span><span>    try </span>{<br />      iter = <b>Merger.merge(jobConf<span>, </span>rfs<span>,<br /></span>                         (Class&lt;K&gt;) jobConf.getMapOutputKeyClass()<span>,<br /></span>                         (Class&lt;V&gt;) jobConf.getMapOutputValueClass()<span>,<br /></span>                          codec<span>, </span>inputs.toArray(<span>new </span>Path[inputs.size()])<span>, <br /></span><span>                          true, </span>ioSortFactor<span>, </span>tmpDir<span>, <br /></span>                         (RawComparator&lt;K&gt;) jobConf.getOutputKeyComparator()<span>, <br /></span>                         reporter<span>, </span>spilledRecordsCounter<span>, null, <br /></span>                         mergedMapOutputsCounter<span>, null</span>)</b><span><b>;</b><br /></span><span><br /></span>      Merger.writeFile(iter<span>, </span>writer<span>, </span>reporter<span>, </span>jobConf)<span>;<br /></span>      writer.close()<span>;<br /></span>      compressAwarePath = <span>new </span>CompressAwarePath(outputPath<span>,   <br /></span>      writer.getRawLength()<span>, </span>writer.getCompressedLength())<span>;<br /></span>    } <span>catch </span>(IOException e) {<br />      localFS.delete(outputPath<span>, true</span>)<span>;<br /></span><span>      throw </span>e<span>;<br /></span>    }<br /><br />    closeOnDiskFile(compressAwarePath)<span>;<br /></span><span><br /></span>    LOG.info(reduceId +<br /><span>             " Finished merging " </span>+ inputs.size() + <br /><span>             " map output files on disk of total-size " </span>+ <br />             approxOutputSize + <span>"." </span>+ <br /><span>             " Local output file is " </span>+ outputPath + <span>" of size " </span>+<br />             localFS.getFileStatus(outputPath).getLen())<span>;<br /></span>  }<br />}</pre></pre></pre></pre></pre></div></div></foreignObject><text x="324" y="559" fill="#333333" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><path d="M 2980.29 840 L 3494.57 1401.43" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/><rect x="785" y="635" width="620" height="1170" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(789.5,624.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="598" height="1176" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 1179px; max-width: 609px; width: 599px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>Shuffle.java</h1><pre>@Override<br /><span>public </span>RawKeyValueIterator run() <span>throws </span>IOException<span>, </span>InterruptedException {<br /><span>  // Scale the maximum events we fetch per RPC call to mitigate OOM issues<br /></span><span>  // on the ApplicationMaster when a thundering herd of reducers fetch events<br /></span><span>  // TODO: This should not be necessary after HADOOP-8942<br /></span><span>  int </span>eventsPerReducer = Math.max(MIN_EVENTS_TO_FETCH<span>,<br /></span>  MAX_RPC_OUTSTANDING_EVENTS / jobConf.getNumReduceTasks())<span>;<br /></span><span>  int </span>maxEventsToFetch = Math.min(MAX_EVENTS_TO_FETCH<span>, </span>eventsPerReducer)<span>;<br /></span><span><br /></span><span>  // Start the map-completion events fetcher thread<br /></span><span>  final </span>EventFetcher&lt;K<span>, </span>V&gt; eventFetcher =<br /><span>       new </span>EventFetcher&lt;K<span>, </span>V&gt;(reduceId<span>, </span>umbilical<span>, </span>scheduler<span>, this,<br /></span>       maxEventsToFetch)<span>;<br /></span>  eventFetcher.start()<span>;<br /></span><span><br /></span><span>  // Start the map-output fetcher threads<br /></span><span>  boolean </span>isLocal = localMapFiles != <span>null;<br /></span><span>  final int </span>numFetchers = isLocal ? <span>1 </span>:<br />      jobConf.getInt(MRJobConfig.SHUFFLE_PARALLEL_COPIES<span>, </span><span>5</span>)<span>;<br /></span>  Fetcher&lt;K<span>, </span>V&gt;[] fetchers = <span>new </span>Fetcher[numFetchers]<span>;<br /></span><span>  if </span>(isLocal) {<br />    fetchers[<span>0</span>] = <span>new </span>LocalFetcher&lt;K<span>, </span>V&gt;(jobConf<span>, </span>reduceId<span>, </span>scheduler<span>,<br /></span>                    merger<span>, </span>reporter<span>, </span>metrics<span>, this, </span>reduceTask.getShuffleSecret()<span>,<br /></span>                    localMapFiles)<span>;<br /></span><b>    fetchers[<span>0</span>].start()<span>;<br /></span></b>  } <span>else </span>{<br /><span>    for </span>(<span>int </span>i=<span>0</span><span>; </span>i &lt; numFetchers<span>; </span>++i) {<br />      fetchers[i] = <span>new </span>Fetcher&lt;K<span>, </span>V&gt;(jobConf<span>, </span>reduceId<span>, </span>scheduler<span>, </span>merger<span>,<br /></span>                                     reporter<span>, </span>metrics<span>, this, <br /></span>                                     reduceTask.getShuffleSecret())<span>;<br /></span><b>      fetchers[i].start()<span>;<br /></span></b>    }<br />  }<br /><br /><span>  // Wait for shuffle to complete successfully<br /></span><span>  while </span>(!scheduler.waitUntilDone(PROGRESS_FREQUENCY)) {<br />    reporter.progress()<span>;<br /></span><span><br /></span><span>    synchronized </span>(<span>this</span>) {<br /><span>      if </span>(throwable != <span>null</span>) {<br /><span>        throw new </span>ShuffleError(<span>"error in shuffle in " </span>+ throwingThreadName<span>,<br /></span>                               throwable)<span>;<br /></span>      }<br />    }<br />  }<br /><br /><span>  // Stop the event-fetcher thread<br /></span>  eventFetcher.shutDown()<span>;<br /></span><span><br /></span><span>  // Stop the map-output fetcher threads<br /></span><span>  for </span>(Fetcher&lt;K<span>, </span>V&gt; fetcher : fetchers) {<br />    fetcher.shutDown()<span>;<br /></span>  }<br /><br /><span>  // stop the scheduler<br /></span>  scheduler.close()<span>;<br /></span><span><br /></span>  copyPhase.complete()<span>; </span><span>// copy is already complete<br /></span>  taskStatus.setPhase(TaskStatus.Phase.SORT)<span>;<br /></span>  reduceTask.statusUpdate(umbilical)<span>;<br /></span><span><br /></span><span>  // Finish the on-going merges...<br /></span>  RawKeyValueIterator kvIter = <span>null;<br /></span><span>  try </span>{<br /><b>    kvIter = merger.close()<span>;<br /></span></b>  } <span>catch </span>(Throwable e) {<br /><span>    throw new </span>ShuffleError(<span>"Error while doing final merge "</span><span>, </span>e)<span>;<br /></span>  }<br /><br /><span>  // Sanity check<br /></span><span>  synchronized </span>(<span>this</span>) {<br /><span>    if </span>(throwable != <span>null</span>) {<br /><span>      throw new </span>ShuffleError(<span>"error in shuffle in " </span>+ throwingThreadName<span>,<br /></span>                           throwable)<span>;<br /></span>    }<br />  }<br /><br /><span>  return </span>kvIter<span>;<br /></span>}</pre></div></div></foreignObject><text x="299" y="594" fill="#333333" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><path d="M 784.57 1778.57 L 283.54 935.47" fill="none" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 280.86 930.96 L 287.44 935.19 L 283.54 935.47 L 281.42 938.77 Z" fill="#6c8ebf" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 280 920 L 773.01 708.23" fill="none" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 777.83 706.16 L 772.78 712.13 L 773.01 708.23 L 770.02 705.7 Z" fill="#82b366" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><rect x="1542.5" y="635" width="430" height="370" fill="#e1d5e7" stroke="#9673a6" pointer-events="none"/><g transform="translate(1547.5,624.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="410" height="378" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 379px; max-width: 419px; width: 411px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>LocalFetcher.java</h1><pre><pre><span>public void </span>run() {<br /><span>  // Create a worklist of task attempts to work over.<br /></span>  Set&lt;TaskAttemptID&gt; maps = <span>new </span>HashSet&lt;TaskAttemptID&gt;()<span>;<br /></span><span>  for </span>(TaskAttemptID map : localMapFiles.keySet()) {<br />    maps.add(map)<span>;<br /></span>  }<br /><br /><span>  while </span>(maps.size() &gt; <span>0</span>) {<br /><span>    try </span>{<br /><span>      // If merge is on, block<br /></span><b>      merger.waitForResource()<span>;<br /></span></b>      metrics.threadBusy()<span>;<br /></span><span><br /></span><span>      // Copy as much as is possible.<br /></span>      doCopy(maps)<span>;<br /></span>      metrics.threadFree()<span>;<br /></span>    } <span>catch </span>(InterruptedException ie) {<br />    } <span>catch </span>(Throwable t) {<br />      exceptionReporter.reportException(t)<span>;<br /></span>    }<br />  }<br />}</pre></pre></div></div></foreignObject><text x="205" y="195" fill="#000000" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><rect x="1460" y="1110" width="490" height="440" fill="#e1d5e7" stroke="#9673a6" pointer-events="none"/><g transform="translate(1464.5,1099.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="468" height="448" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(0, 0, 0); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 449px; max-width: 479px; width: 469px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>Fetcher.java</h1><pre><pre><pre><span>public void </span>run() {<br /><span>  try </span>{<br /><span>    while </span>(!stopped &amp;&amp; !Thread.currentThread().isInterrupted()) {<br />      MapHost host = <span>null;<br /></span><span>      try </span>{<br /><span>        // If merge is on, block<br /></span><b>        merger.waitForResource()<span>;<br /></span></b><span><br /></span><span>        // Get a host to shuffle from<br /></span><b>        host = scheduler.getHost()<span>;<br /></span></b>        metrics.threadBusy()<span>;<br /></span><span><br /></span><span>        // Shuffle<br /></span>        <b>copyFromHost(host)</b><span><b>;</b><br /></span>      } <span>finally </span>{<br /><span>        if </span>(host != <span>null</span>) {<br />          scheduler.freeHost(host)<span>;<br /></span>          metrics.threadFree()<span>;            <br /></span>        }<br />      }<br />    }<br />  } <span>catch </span>(InterruptedException ie) {<br /><span>    return;<br /></span>  } <span>catch </span>(Throwable t) {<br />    exceptionReporter.reportException(t)<span>;<br /></span>  }<br />}<br /></pre></pre></pre></div></div></foreignObject><text x="234" y="230" fill="#000000" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><path d="M 970.29 1020 L 1534.76 696.03" fill="none" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 1539.32 693.41 L 1534.99 699.93 L 1534.76 696.03 L 1531.5 693.86 Z" fill="#82b366" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 984.57 1114.29 L 1451.1 1166.44" fill="none" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 1456.32 1167.02 L 1448.97 1169.72 L 1451.1 1166.44 L 1449.75 1162.76 Z" fill="#82b366" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 1454.57 1531.43 L 985.1 1124.17" fill="none" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 981.13 1120.73 L 988.71 1122.68 L 985.1 1124.17 L 984.12 1127.96 Z" fill="#6c8ebf" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 1537.43 985.71 L 976.35 1029.5" fill="none" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 971.11 1029.91 L 977.82 1025.88 L 976.35 1029.5 L 978.37 1032.86 Z" fill="#6c8ebf" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><rect x="2830" y="1640" width="590" height="1690" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(2834.5,1629.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="569" height="1694" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 1699px; max-width: 579px; width: 570px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>Fetcher.java</h1><pre><pre><pre><pre><span>private </span>TaskAttemptID[] copyMapOutput(MapHost host<span>,<br /></span>                              DataInputStream input<span>,<br /></span>                              Set&lt;TaskAttemptID&gt; remaining<span>,<br /></span><span>                              boolean </span>canRetry) <span>throws </span>IOException {<br />  MapOutput&lt;K<span>,</span>V&gt; mapOutput = <span>null;<br /></span>  TaskAttemptID mapId = <span>null;<br /></span><span>  long </span>decompressedLength = -<span>1</span><span>;<br /></span><span>  long </span>compressedLength = -<span>1</span><span>;<br /></span><span><br /></span><span>  try </span>{<br /><span>    long </span>startTime = Time.monotonicNow()<span>;<br /></span><span>    int </span>forReduce = -<span>1</span><span>;<br /></span><span>    //Read the shuffle header<br /></span><span>    try </span>{<br />      ShuffleHeader header = <span>new </span>ShuffleHeader()<span>;<br /></span>      header.readFields(input)<span>;<br /></span>      mapId = TaskAttemptID.forName(header.mapId)<span>;<br /></span>      compressedLength = header.compressedLength<span>;<br /></span>      decompressedLength = header.uncompressedLength<span>;<br /></span>      forReduce = header.forReduce<span>;<br /></span>    } <span>catch </span>(IllegalArgumentException e) {<br />      badIdErrs.increment(<span>1</span>)<span>;<br /></span>      LOG.warn(<span>"Invalid map id "</span><span>, </span>e)<span>;<br /></span><span>      //Don't know which one was bad, so consider all of them as bad<br /></span><span>      return </span>remaining.toArray(<span>new </span>TaskAttemptID[remaining.size()])<span>;<br /></span>    }<br /><br />    InputStream is = input<span>;<br /></span>    is = CryptoUtils.wrapIfNecessary(jobConf<span>, </span>is<span>, </span>compressedLength)<span>;<br /></span>    compressedLength -= CryptoUtils.cryptoPadding(jobConf)<span>;<br /></span>    decompressedLength -= CryptoUtils.cryptoPadding(jobConf)<span>;<br /></span><span><br /></span><span>    // Do some basic sanity verification<br /></span><span>    if </span>(!verifySanity(compressedLength<span>, </span>decompressedLength<span>, </span>forReduce<span>,<br /></span>      remaining<span>, </span>mapId)) {<br /><span>      return new </span>TaskAttemptID[] {mapId}<span>;<br /></span>    }<br /><br /><span>    if</span>(LOG.isDebugEnabled()) {<br />      LOG.debug(<span>"header: " </span>+ mapId + <span>", len: " </span>+ compressedLength + <br /><span>                ", decomp len: " </span>+ decompressedLength)<span>;<br /></span>    }<br /><br /><span>    // Get the location for the map output - either in-memory or on-disk<br /></span><span>    try </span>{<br /><b>      mapOutput = merger.reserve(mapId<span>, </span>decompressedLength<span>, </span>id)<span>;<br /></span></b>    } <span>catch </span>(IOException ioe) {<br /><span>      // kill this reduce attempt<br /></span>      ioErrs.increment(<span>1</span>)<span>;<br /></span>      scheduler.reportLocalError(ioe)<span>;<br /></span><span>      return </span>EMPTY_ATTEMPT_ID_ARRAY<span>;<br /></span>    }<br /><br /><span>    // Check if we can shuffle *now* ...<br /></span><span>    if </span>(mapOutput == <span>null</span>) {<br />      LOG.info(<span>"fetcher#" </span>+ id + <span>" - MergeManager returned status WAIT ..."</span>)<span>;<br /></span><span>      //Not an error but wait to process data.<br /></span><span>      return </span>EMPTY_ATTEMPT_ID_ARRAY<span>;<br /></span>    } <br /><br /><span>    // The codec for lz0,lz4,snappy,bz2,etc. throw java.lang.InternalError<br /></span><span>    // on decompression failures. Catching and re-throwing as IOException<br /></span><span>    // to allow fetch failure logic to be processed<br /></span><span>    try </span>{<br /><span>      // Go!<br /></span>      LOG.info(<span>"fetcher#" </span>+ id + <span>" about to shuffle output of map "<br /></span>          + mapOutput.getMapId() + <span>" decomp: " </span>+ decompressedLength<br />          + <span>" len: " </span>+ compressedLength + <span>" to " </span>+ mapOutput.getDescription())<span>;<br /></span>      mapOutput.shuffle(host<span>, </span>is<span>, </span>compressedLength<span>, </span>decompressedLength<span>,<br /></span>      metrics<span>, </span>reporter)<span>;<br /></span>    } <span>catch </span>(java.lang.InternalError | Exception e) {<br />      LOG.warn(<span>"Failed to shuffle for fetcher#"</span>+id<span>, </span>e)<span>;<br /></span><span>      throw new </span>IOException(e)<span>;<br /></span>    }<br /><br /><span>    // Inform the shuffle scheduler<br /></span><span>    long </span>endTime = Time.monotonicNow()<span>;<br /></span><span>    // Reset retryStartTime as map task make progress if retried before.<br /></span>    retryStartTime = <span>0</span><span>;<br /></span><span><br /></span><b>    scheduler.copySucceeded(mapId<span>, </span>host<span>, </span>compressedLength<span>, <br /></span></b>    startTime<span>, </span>endTime<span>, </span>mapOutput)<span>;<br /></span><span>    // Note successful shuffle<br /></span>    remaining.remove(mapId)<span>;<br /></span>    metrics.successFetch()<span>;<br /></span><span>    return null;<br /></span>  } <span>catch </span>(IOException ioe) {<br /><span>    if </span>(mapOutput != <span>null</span>) {<br />      mapOutput.abort()<span>;<br /></span>    }<br /><br /><span>    if </span>(canRetry) {<br />      checkTimeoutOrRetry(host<span>, </span>ioe)<span>;<br /></span>    } <br /><br />    ioErrs.increment(<span>1</span>)<span>;<br /></span><span>    if </span>(mapId == <span>null </span>|| mapOutput == <span>null</span>) {<br />      LOG.warn(<span>"fetcher#" </span>+ id + <span>" failed to read map header" </span>+ <br />               mapId + <span>" decomp: " </span>+ <br />               decompressedLength + <span>", " </span>+ compressedLength<span>, </span>ioe)<span>;<br /></span><span>      if</span>(mapId == <span>null</span>) {<br /><span>        return </span>remaining.toArray(<span>new </span>TaskAttemptID[remaining.size()])<span>;<br /></span>      } <span>else </span>{<br /><span>        return new </span>TaskAttemptID[] {mapId}<span>;<br /></span>      }<br />    }<br /><br />    LOG.warn(<span>"Failed to shuffle output of " </span>+ mapId + <br /><span>             " from " </span>+ host.getHostName()<span>, </span>ioe)<span>; <br /></span><span><br /></span><span>    // Inform the shuffle-scheduler<br /></span>    metrics.failedFetch()<span>;<br /></span><span>    return new </span>TaskAttemptID[] {mapId}<span>;<br /></span>  }<br /><br />}</pre></pre></pre></pre></div></div></foreignObject><text x="285" y="853" fill="#333333" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><path d="M 1660.29 1350 L 2110.29 1704.29" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/><rect x="3592.5" y="2415" width="605" height="650" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(3597.5,2404.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="569" height="658" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 659px; max-width: 594px; width: 570px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>MergeManagerImpl.java</h1><pre><pre><pre><pre><pre>@Override<br /><span>public synchronized </span>MapOutput&lt;K<span>,</span>V&gt; reserve(TaskAttemptID mapId<span>, <br /></span><span>                                           long </span>requestedSize<span>,<br /></span><span>                                           int </span>fetcher<br />                                           ) <span>throws </span>IOException {<br /><span>  if </span>(requestedSize &gt; maxSingleShuffleLimit) {<br />    LOG.info(mapId + <span>": Shuffling to disk since " </span>+ requestedSize + <br /><span>            " is greater than maxSingleShuffleLimit (" </span>+ <br />             maxSingleShuffleLimit + <span>")"</span>)<span>;<br /></span><span>    return new </span>OnDiskMapOutput&lt;K<span>,</span>V&gt;(mapId<span>, this, </span>requestedSize<span>, </span>jobConf<span>,<br /></span>      fetcher<span>, true, </span>FileSystem.getLocal(jobConf).getRaw()<span>,<br /></span>        mapOutputFile.getInputFileForWrite(mapId.getTaskID()<span>, </span>requestedSize))<span>;<br /></span>  }<br /><br /><span>  // Stall shuffle if we are above the memory limit<br /></span><span><br /></span><span>  // It is possible that all threads could just be stalling and not make<br /></span><span>  // progress at all. This could happen when:<br /></span><span>  //<br /></span><span>  // requested size is causing the used memory to go above limit &amp;&amp;<br /></span><span>  // requested size &lt; singleShuffleLimit &amp;&amp;<br /></span><span>  // current used size &lt; mergeThreshold (merge will not get triggered)<br /></span><span>  //<br /></span><span>  // To avoid this from happening, we allow exactly one thread to go past<br /></span><span>  // the memory limit. We check (usedMemory &gt; memoryLimit) and not<br /></span><span>  // (usedMemory + requestedSize &gt; memoryLimit). When this thread is done<br /></span><span>  // fetching, this will automatically trigger a merge thereby unlocking<br /></span><span>  // all the stalled threads<br /></span><span><br /></span><span>  if </span>(usedMemory &gt; memoryLimit) {<br />    LOG.debug(mapId + <span>": Stalling shuffle since usedMemory (" </span>+ usedMemory<br />        + <span>") is greater than memoryLimit (" </span>+ memoryLimit + <span>")." </span>+ <br /><span>        " CommitMemory is (" </span>+ commitMemory + <span>")"</span>)<span>; <br /></span><span>    return null;<br /></span>  }<br /><br /><span>  // Allow the in-memory shuffle to progress<br /></span>  LOG.debug(mapId + <span>": Proceeding with shuffle since usedMemory ("<br /></span>           + usedMemory + <span>") is lesser than memoryLimit (" </span>+ memoryLimit + <span>")."<br /></span>           + <span>"CommitMemory is (" </span>+ commitMemory + <span>")"</span>)<span>; <br /></span><span>  return </span>unconditionalReserve(mapId<span>, </span>requestedSize<span>, true</span>)<span>;<br /></span>}</pre></pre></pre></pre></pre></div></div></foreignObject><text x="285" y="335" fill="#333333" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><path d="M 3584.57 2491.43 L 3300.29 2330" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/><rect x="4878" y="2975" width="600" height="410" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(4882.5,2964.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="569" height="419" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 419px; max-width: 589px; width: 570px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>MergeManagerImpl.java</h1><pre><pre><span>public synchronized void </span>closeInMemoryFile(InMemoryMapOutput&lt;K<span>,</span>V&gt; mapOutput) { <br />  inMemoryMapOutputs.add(mapOutput)<span>;<br /></span>  LOG.info(<span>"closeInMemoryFile -&gt; map-output of size: " </span>+ mapOutput.getSize()<br />      + <span>", inMemoryMapOutputs.size() -&gt; " </span>+ inMemoryMapOutputs.size()<br />      + <span>", commitMemory -&gt; " </span>+ commitMemory + <span>", usedMemory -&gt;" </span>+ usedMemory)<span>;<br /></span><span><br /></span>  commitMemory+= mapOutput.getSize()<span>;<br /></span><span><br /></span><span>  // Can hang if mergeThreshold is really low.<br /></span><span>  if </span>(commitMemory &gt;= mergeThreshold) {<br />    LOG.info(<span>"Starting inMemoryMerger's merge since commitMemory=" </span>+<br />        commitMemory + <span>" &gt; mergeThreshold=" </span>+ mergeThreshold + <br /><span>        ". Current usedMemory=" </span>+ usedMemory)<span>;<br /></span>    inMemoryMapOutputs.addAll(inMemoryMergedMapOutputs)<span>;<br /></span>    inMemoryMergedMapOutputs.clear()<span>;<br /></span>    inMemoryMerger.startMerge(inMemoryMapOutputs)<span>;<br /></span>    commitMemory = <span>0L</span><span>;  </span><span>// Reset commitMemory.<br /></span>  }<br /> <br /><span>  if </span>(memToMemMerger != <span>null</span>) {<br /><span>    if </span>(inMemoryMapOutputs.size() &gt;= memToMemMergeOutputsThreshold) { <br />      memToMemMerger.startMerge(inMemoryMapOutputs)<span>;<br /></span>    }<br />  }<br />}</pre></pre></div></div></foreignObject><text x="285" y="215" fill="#333333" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><rect x="2110" y="1640" width="600" height="1155" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(2114.5,1629.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="569" height="1162" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 1164px; max-width: 589px; width: 570px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>Fetcher.java</h1><pre><pre><pre>@VisibleForTesting<br /><span>protected void </span>copyFromHost(MapHost host) <span>throws </span>IOException {<br /><span>  // reset retryStartTime for a new host<br /></span>  retryStartTime = <span>0</span><span>;<br /></span><span>  // Get completed maps on 'host'<br /></span>  List&lt;TaskAttemptID&gt; maps = scheduler.getMapsForHost(host)<span>;<br /></span><span><br /></span><span>  // Sanity check to catch hosts with only 'OBSOLETE' maps, <br /></span><span>  // especially at the tail of large jobs<br /></span><span>  if </span>(maps.size() == <span>0</span>) {<br /><span>    return;<br /></span>  }<br /><br /><span>  if</span>(LOG.isDebugEnabled()) {<br />    LOG.debug(<span>"Fetcher " </span>+ id + <span>" going to fetch from " </span>+ host + <span>" for: "<br /></span>             + maps)<span>;<br /></span>  }<br /><br /><span>  // List of maps to be fetched yet<br /></span>  Set&lt;TaskAttemptID&gt; remaining = <span>new </span>HashSet&lt;TaskAttemptID&gt;(maps)<span>;<br /></span><span><br /></span><span>  // Construct the url and connect<br /></span>  URL url = getMapOutputURL(host<span>, </span>maps)<span>;<br /></span>  DataInputStream input = <span>null;<br /></span><span><br /></span><span>  try </span>{<br />    input = openShuffleUrl(host<span>, </span>remaining<span>, </span>url)<span>;<br /></span><span>    if </span>(input == <span>null</span>) {<br /><span>      return;<br /></span>    }<br /><br /><span>    // Loop through available map-outputs and fetch them<br /></span><span>    // On any error, faildTasks is not null and we exit<br /></span><span>    // after putting back the remaining maps to the <br /></span><span>    // yet_to_be_fetched list and marking the failed tasks.<br /></span>    TaskAttemptID[] failedTasks = <span>null;<br /></span><span>    while </span>(!remaining.isEmpty() &amp;&amp; failedTasks == <span>null</span>) {<br /><span>      try </span>{<br />        <b>failedTasks = copyMapOutput(host<span>, </span>input<span>, </span>remaining<span>, </span>fetchRetryEnabled)</b><span><b>;</b><br /></span>      } <span>catch </span>(IOException e) {<br />        IOUtils.cleanupWithLogger(LOG<span>, </span>input)<span>;<br /></span><span>        //<br /></span><span>        // Setup connection again if disconnected by NM<br /></span>        connection.disconnect()<span>;<br /></span><span>        // Get map output from remaining tasks only.<br /></span>        url = getMapOutputURL(host<span>, </span>remaining)<span>;<br /></span>        input = openShuffleUrl(host<span>, </span>remaining<span>, </span>url)<span>;<br /></span><span>        if </span>(input == <span>null</span>) {<br /><span>          return;<br /></span>        }<br />      }<br />    }<br /><br /><span>    if</span>(failedTasks != <span>null </span>&amp;&amp; failedTasks.length &gt; <span>0</span>) {<br />      LOG.warn(<span>"copyMapOutput failed for tasks "</span>+Arrays.toString(failedTasks))<span>;<br /></span>      scheduler.hostFailed(host.getHostName())<span>;<br /></span><span>      for</span>(TaskAttemptID left: failedTasks) {<br />        scheduler.copyFailed(left<span>, </span>host<span>, true, false</span>)<span>;<br /></span>      }<br />    }<br /><br /><span>    // Sanity check<br /></span><span>    if </span>(failedTasks == <span>null </span>&amp;&amp; !remaining.isEmpty()) {<br /><span>      throw new </span>IOException(<span>"server didn't return all expected map outputs: "<br /></span>                           + remaining.size() + <span>" left."</span>)<span>;<br /></span>    }<br />    input.close()<span>;<br /></span>    input = <span>null;<br /></span>  } <span>finally </span>{<br /><span>    if </span>(input != <span>null</span>) {<br />      IOUtils.cleanupWithLogger(LOG<span>, </span>input)<span>;<br /></span>      input = <span>null;<br /></span>    }<br /><span>    for </span>(TaskAttemptID left : remaining) {<br />      scheduler.putBackKnownMapOutput(host<span>, </span>left)<span>;<br /></span>    }<br />  }<br />}</pre></pre></pre></div></div></foreignObject><text x="285" y="587" fill="#333333" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><path d="M 2828.86 1701.43 L 2690.29 2234.29" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/><rect x="3630" y="3110" width="530" height="610" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(3634.5,3099.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="497" height="616" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 619px; max-width: 519px; width: 498px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>ShuffleSchedulerImpl.java</h1><pre><pre><pre><pre><pre><pre><span>public synchronized void </span>copySucceeded(TaskAttemptID mapId<span>,<br /></span>                                       MapHost host<span>,<br /></span><span>                                       long </span>bytes<span>,<br /></span><span>                                       long </span>startMillis<span>,<br /></span><span>                                       long </span>endMillis<span>,<br /></span>                                       MapOutput&lt;K<span>,</span>V&gt; output<br />                                       ) <span>throws </span>IOException {<br />  failureCounts.remove(mapId)<span>;<br /></span>  hostFailures.remove(host.getHostName())<span>;<br /></span><span>  int </span>mapIndex = mapId.getTaskID().getId()<span>;<br /></span><span><br /></span><span>  if </span>(!finishedMaps[mapIndex]) {<br /><b>    output.commit()<span>;<br /></span></b>    finishedMaps[mapIndex] = <span>true;<br /></span>    shuffledMapsCounter.increment(<span>1</span>)<span>;<br /></span><span>    if </span>(--remainingMaps == <span>0</span>) {<br />      notifyAll()<span>;<br /></span>    }<br /><br /><span>    // update single copy task status<br /></span><span>    long </span>copyMillis = (endMillis - startMillis)<span>;<br /></span><span>    if </span>(copyMillis == <span>0</span>) copyMillis = <span>1</span><span>;<br /></span><span>    float </span>bytesPerMillis = (<span>float</span>) bytes / copyMillis<span>;<br /></span><span>    float </span>transferRate = bytesPerMillis * BYTES_PER_MILLIS_TO_MBS<span>;<br /></span>    String individualProgress = <span>"copy task(" </span>+ mapId + <span>" succeeded"<br /></span>               + <span>" at " </span>+ mbpsFormat.format(transferRate) + <span>" MB/s)"</span><span>;<br /></span><span>    // update the aggregated status<br /></span>    copyTimeTracker.add(startMillis<span>, </span>endMillis)<span>;<br /></span><span><br /></span>    totalBytesShuffledTillNow += bytes<span>;<br /></span>    updateStatus(individualProgress)<span>;<br /></span>    reduceShuffleBytes.increment(bytes)<span>;<br /></span>    lastProgressTime = Time.monotonicNow()<span>;<br /></span>    LOG.debug(<span>"map " </span>+ mapId + <span>" done " </span>+ status.getStateString())<span>;<br /></span>  } <span>else </span>{<br />    LOG.warn(<span>"Aborting already-finished MapOutput for " </span>+ mapId)<span>;<br /></span>    output.abort()<span>;<br /></span>  }<br />}</pre></pre></pre></pre></pre></pre></div></div></foreignObject><text x="249" y="314" fill="#333333" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><path d="M 3630.29 3165.71 L 3250.29 2810" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/><rect x="4233" y="3120" width="340" height="120" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(4237.5,3109.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="295" height="126" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 129px; max-width: 329px; width: 296px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>InMemoryMapOutput.java</h1><pre><pre><pre><pre><pre><pre><pre>@Override<br /><span>public void </span>commit() <span>throws </span>IOException {<br /><b>  getMerger().closeInMemoryFile(<span>this</span>)<span>;<br /></span></b>}</pre></pre></pre></pre></pre></pre></pre></div></div></foreignObject><text x="148" y="69" fill="#333333" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><path d="M 4233.14 3180 L 3810 3330" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/><path d="M 4878.86 3031.43 L 4513.14 3210" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/><rect x="4230" y="3430" width="533" height="160" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(4234.5,3419.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="522" height="168" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 169px; max-width: 522px; width: 521.571px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>OnDiskMapOutput.java</h1><pre><pre><pre><pre><pre><pre><pre><pre>@Override<br /><span>public void </span>commit() <span>throws </span>IOException {<br />  fs.rename(tmpOutputPath<span>, </span>outputPath)<span>;<br /></span>  CompressAwarePath compressAwarePath = <span>new </span>CompressAwarePath(outputPath<span>,<br /></span>    getSize()<span>, this</span>.compressedSize)<span>;<br /></span><b>  getMerger().closeOnDiskFile(compressAwarePath)<span>;<br /></span></b>}</pre></pre></pre></pre></pre></pre></pre></pre></div></div></foreignObject><text x="261" y="90" fill="#333333" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><path d="M 4227.43 3501.43 L 3790.29 3330" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/><rect x="4981" y="3430" width="500" height="160" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(4985.5,3419.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="475" height="168" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 169px; max-width: 489px; width: 476px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>MergeManagerImpl.java</h1><pre><pre><pre><pre><pre><pre><pre><pre><pre><span>public synchronized void </span>closeOnDiskFile(CompressAwarePath file) {<br />  onDiskMapOutputs.add(file)<span>;<br /></span><span><br /></span><span>  if </span>(onDiskMapOutputs.size() &gt;= (<span>2 </span>* ioSortFactor - <span>1</span>)) {<br />    onDiskMerger.startMerge(onDiskMapOutputs)<span>;<br /></span>  }<br />}</pre></pre></pre></pre></pre></pre></pre></pre></pre></div></div></foreignObject><text x="238" y="90" fill="#333333" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><path d="M 4986 3490 L 4583.14 3560" fill="none" stroke="#d6b656" stroke-width="3" stroke-miterlimit="10" stroke-dasharray="9 9" pointer-events="none"/><rect x="1085" y="1840" width="640" height="320" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(1089.5,1829.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="605" height="322" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 329px; max-width: 629px; width: 606px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>MergeManagerImpl.java</h1><pre><pre>@Override<br /><span>public </span>RawKeyValueIterator close() <span>throws </span>Throwable {<br /><span>  // Wait for on-going merges to complete<br /></span><span>  if </span>(memToMemMerger != <span>null</span>) { <br />    memToMemMerger.close()<span>;<br /></span>  }<br />  inMemoryMerger.close()<span>;<br /></span>  onDiskMerger.close()<span>;<br /></span><span><br /></span>  List&lt;InMemoryMapOutput&lt;K<span>, </span>V&gt;&gt; memory = <br /><span>    new </span>ArrayList&lt;InMemoryMapOutput&lt;K<span>, </span>V&gt;&gt;(inMemoryMergedMapOutputs)<span>;<br /></span>  inMemoryMergedMapOutputs.clear()<span>;<br /></span>  memory.addAll(inMemoryMapOutputs)<span>;<br /></span>  inMemoryMapOutputs.clear()<span>;<br /></span>  List&lt;CompressAwarePath&gt; disk = <span>new </span>ArrayList&lt;CompressAwarePath&gt;(onDiskMapOutputs)<span>;<br /></span>  onDiskMapOutputs.clear()<span>;<br /></span><b><span>  return </span>finalMerge(jobConf<span>, </span>rfs<span>, </span>memory<span>, </span>disk)<span>;<br /></span></b>}</pre></pre></div></div></foreignObject><text x="303" y="167" fill="#333333" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><rect x="1340" y="2260" width="730" height="2040" fill="#f5f5f5" stroke="#666666" pointer-events="none"/><g transform="translate(1344.5,2249.5)"><switch><foreignObject style="overflow:visible;" pointer-events="all" width="691" height="2044" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"><div xmlns="http://www.w3.org/1999/xhtml" style="display: inline-block; font-size: 12px; font-family: Helvetica; color: rgb(51, 51, 51); line-height: 1.2; vertical-align: top; overflow: hidden; max-height: 2049px; max-width: 719px; width: 692px; white-space: normal; overflow-wrap: normal;"><div xmlns="http://www.w3.org/1999/xhtml" style="display:inline-block;text-align:inherit;text-decoration:inherit;white-space:normal;"><h1>MergeManagerImpl.java</h1><pre><pre><pre>private RawKeyValueIterator finalMerge(JobConf job, FileSystem fs,<br />                                       List&lt;InMemoryMapOutput&lt;K,V&gt;&gt; inMemoryMapOutputs,<br />                                       List&lt;CompressAwarePath&gt; onDiskMapOutputs<br />                                     ) throws IOException {<br />  LOG.info("finalMerge called with " +<br />      inMemoryMapOutputs.size() + " in-memory map-outputs and " +<br />      onDiskMapOutputs.size() + " on-disk map-outputs");<br />  final long maxInMemReduce = getMaxInMemReduceLimit();<br />  // merge config params<br />  Class&lt;K&gt; keyClass = (Class&lt;K&gt;)job.getMapOutputKeyClass();<br />  Class&lt;V&gt; valueClass = (Class&lt;V&gt;)job.getMapOutputValueClass();<br />  boolean keepInputs = job.getKeepFailedTaskFiles();<br />  final Path tmpDir = new Path(reduceId.toString());<br />  final RawComparator&lt;K&gt; comparator =<br />    (RawComparator&lt;K&gt;)job.getOutputKeyComparator();<br /><br />  // segments required to vacate memory <br />  List&lt;Segment&lt;K,V&gt;&gt; memDiskSegments = new ArrayList&lt;Segment&lt;K,V&gt;&gt;();<br />  long inMemToDiskBytes = 0;<br />  boolean mergePhaseFinished = false;<br />  if (inMemoryMapOutputs.size() &gt; 0) {<br />    TaskID mapId = inMemoryMapOutputs.get(0).getMapId().getTaskID();<br />    inMemToDiskBytes = createInMemorySegments(inMemoryMapOutputs, <br />    memDiskSegments,<br />    maxInMemReduce);<br />    final int numMemDiskSegments = memDiskSegments.size();<br />    if (numMemDiskSegments &gt; 0 &amp;&amp;<br />          ioSortFactor &gt; onDiskMapOutputs.size()) {<br /><br />      // If we reach here, it implies that we have less than io.sort.factor<br />      // disk segments and this will be incremented by 1 (result of the <br />      // memory segments merge). Since this total would still be <br />      // &lt;= io.sort.factor, we will not do any more intermediate merges,<br />      // the merge of all these disk segments would be directly fed to the<br />      // reduce method<br /><br />      mergePhaseFinished = true;<br />      // must spill to disk, but can't retain in-mem for intermediate merge<br />      final Path outputPath = <br />        mapOutputFile.getInputFileForWrite(mapId,<br />                                             inMemToDiskBytes).suffix(<br />                                               Task.MERGED_OUTPUT_PREFIX);<br />      <b>final </b><b>RawKeyValueIterator rIter = Merger.merge(job<span>, </span>fs<span>,<br /></span>        keyClass<span>, </span>valueClass<span>, </span>memDiskSegments<span>, </span>numMemDiskSegments<span>,<br /></span>        tmpDir<span>, </span>comparator<span>, </span>reporter<span>, </span>spilledRecordsCounter<span>, null, <br /></span>        mergePhase)<span>;<br /></span><span><br /></span></b>      FSDataOutputStream out = CryptoUtils.wrapIfNecessary(job, fs.create(outputPath));<br />      Writer&lt;K, V&gt; writer = new Writer&lt;K, V&gt;(job, out, keyClass, valueClass,<br />        codec, null, true);<br />      try {<br />        Merger.writeFile(rIter, writer, reporter, job);<br />        writer.close();<br />        onDiskMapOutputs.add(new CompressAwarePath(outputPath,<br />        writer.getRawLength(), writer.getCompressedLength()));<br />        writer = null;<br />        // add to list of final disk outputs.<br />      } catch (IOException e) {<br />        if (null != outputPath) {<br />          try {<br />            fs.delete(outputPath, true);<br />          } catch (IOException ie) {<br />            // NOTHING<br />          }<br />        }<br />        throw e;<br />      } finally {<br />        if (null != writer) {<br />          writer.close();<br />        }<br />      }<br />      LOG.info("Merged " + numMemDiskSegments + " segments, " +<br />               inMemToDiskBytes + " bytes to disk to satisfy " +<br />               "reduce memory limit");<br />      inMemToDiskBytes = 0;<br />      memDiskSegments.clear();<br />    } else if (inMemToDiskBytes != 0) {<br />      LOG.info("Keeping " + numMemDiskSegments + " segments, " +<br />               inMemToDiskBytes + " bytes in memory for " +<br />               "intermediate, on-disk merge");<br />    }<br />  }<br /><br />  // segments on disk<br />  List&lt;Segment&lt;K,V&gt;&gt; diskSegments = new ArrayList&lt;Segment&lt;K,V&gt;&gt;();<br />  long onDiskBytes = inMemToDiskBytes;<br />  long rawBytes = inMemToDiskBytes;<br />  CompressAwarePath[] onDisk = onDiskMapOutputs.toArray(<br />  new CompressAwarePath[onDiskMapOutputs.size()]);<br />  for (CompressAwarePath file : onDisk) {<br />    long fileLength = fs.getFileStatus(file).getLen();<br />    onDiskBytes += fileLength;<br />    rawBytes += (file.getRawDataLength() &gt; 0) ? file.getRawDataLength() : fileLength;<br /><br />    LOG.debug("Disk file: " + file + " Length is " + fileLength);<br />    diskSegments.add(new Segment&lt;K, V&gt;(job, fs, file, codec, keepInputs,<br />                                        (file.toString().endsWith(<br />                                           Task.MERGED_OUTPUT_PREFIX) ?<br />                                        null : mergedMapOutputsCounter), file.getRawDataLength()<br />                                      ));<br />  }<br />  LOG.info("Merging " + onDisk.length + " files, " +<br />           onDiskBytes + " bytes from disk");<br />  Collections.sort(diskSegments, new Comparator&lt;Segment&lt;K,V&gt;&gt;() {<br />    public int compare(Segment&lt;K, V&gt; o1, Segment&lt;K, V&gt; o2) {<br />      if (o1.getLength() == o2.getLength()) {<br />        return 0;<br />      }<br />      return o1.getLength() &lt; o2.getLength() ? -1 : 1;<br />    }<br />  });<br /><br />  // build final list of segments from merged backed by disk + in-mem<br />  List&lt;Segment&lt;K,V&gt;&gt; finalSegments = new ArrayList&lt;Segment&lt;K,V&gt;&gt;();<br />  long inMemBytes = createInMemorySegments(inMemoryMapOutputs, <br />                                           finalSegments, 0);<br />  LOG.info("Merging " + finalSegments.size() + " segments, " +<br />           inMemBytes + " bytes from memory into reduce");<br />  if (0 != onDiskBytes) {<br />    final int numInMemSegments = memDiskSegments.size();<br />    diskSegments.addAll(0, memDiskSegments);<br />    memDiskSegments.clear();<br />    // Pass mergePhase only if there is a going to be intermediate<br />    // merges. See comment where mergePhaseFinished is being set<br />    Progress thisPhase = (mergePhaseFinished) ? null : mergePhase; <br /><b>    RawKeyValueIterator diskMerge = Merger.merge(<br />                           job, fs, keyClass, valueClass, codec, diskSegments,<br />                           ioSortFactor, numInMemSegments, tmpDir, comparator,<br />                           reporter, false, spilledRecordsCounter, null, thisPhase);<br /></b>    diskSegments.clear();<br />    if (0 == finalSegments.size()) { <br />      return diskMerge;<br />    }<br />    finalSegments.add(new Segment&lt;K,V&gt;(<br />                  new RawKVIteratorReader(diskMerge, onDiskBytes), true, rawBytes));<br />  }<br />  <b>return Merger.merge(job, fs, keyClass, valueClass,<br />                      finalSegments, finalSegments.size(), tmpDir,<br />                      comparator, reporter, spilledRecordsCounter, null,<br />                      null);</b><br />}</pre></pre></pre></div></div></foreignObject><text x="346" y="1028" fill="#333333" text-anchor="middle" font-size="12px" font-family="'Helvetica'">[Not supported by viewer]</text></switch></g><path d="M 995 1590 L 1082.84 1901.01" fill="none" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 1084.27 1906.07 L 1079 1900.28 L 1082.84 1901.01 L 1085.73 1898.38 Z" fill="#82b366" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 1084.57 2138.57 L 991.1 1606.27" fill="none" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 990.19 1601.1 L 994.85 1607.39 L 991.1 1606.27 L 987.96 1608.6 Z" fill="#6c8ebf" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 1240.29 2130 L 1337.28 2311.53" fill="none" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 1339.76 2316.16 L 1333.37 2311.63 L 1337.28 2311.53 L 1339.55 2308.33 Z" fill="#82b366" stroke="#82b366" stroke-miterlimit="10" pointer-events="none"/><path d="M 1336 4275.71 L 1110.95 2136.33" fill="none" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/><path d="M 1110.4 2131.11 L 1114.62 2137.71 L 1110.95 2136.33 L 1107.65 2138.44 Z" fill="#6c8ebf" stroke="#6c8ebf" stroke-miterlimit="10" pointer-events="none"/></g></svg>